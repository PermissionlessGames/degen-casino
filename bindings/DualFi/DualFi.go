// This file was generated by seer: https://github.com/G7DAO/seer.
// seer version: 0.4.0
// seer command: seer evm generate --package DualFi --cli --foundry ../degen-casino/out/DualFi.sol/DualFi.json --source-code ../degen-casino/src/token/ERC20/DualFi.sol --struct DualFi --output ../degen-casino/bindings/DualFi/DualFi.go
// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package DualFi

import (
	"bytes"
	"crypto/rand"
	"errors"
	"io"
	"math/big"
	"net/http"
	"net/url"
	"reflect"
	"strconv"
	"strings"

	"context"

	ethereum "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/event"
	"github.com/ethereum/go-ethereum/signer/core/apitypes"

	// Reference imports to suppress errors if they are not otherwise used.
	"encoding/hex"
	"encoding/json"
	"fmt"
	"os"
	"time"

	"github.com/G7DAO/seer/bindings/CreateCall"
	"github.com/G7DAO/seer/bindings/GnosisSafe"
	"github.com/ethereum/go-ethereum/accounts/keystore"
	"github.com/ethereum/go-ethereum/ethclient"
	"github.com/spf13/cobra"
	"golang.org/x/term"

	// DualFiMetaData contains all meta data concerning the DualFi contract.
	"github.com/ethereum/go-ethereum/common/math"
	"github.com/ethereum/go-ethereum/crypto"
)

var (
	_ = errors.New
	_ = big.NewInt
	_ = strings.NewReader
	_ = ethereum.NotFound
	_ = bind.Bind
	_ = common.Big1
	_ = types.BloomLookup
	_ = event.NewSubscription
	_ = abi.ConvertType
)

var DualFiMetaData = &bind.MetaData{
	ABI: "[{\"type\":\"constructor\",\"inputs\":[{\"name\":\"_name\",\"type\":\"string\",\"internalType\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\",\"internalType\":\"string\"},{\"name\":\"tokenA\",\"type\":\"address\",\"internalType\":\"address\"},{\"name\":\"initialAmount0Token\",\"type\":\"uint256\",\"internalType\":\"uint256\"},{\"name\":\"initialAmountNative\",\"type\":\"uint256\",\"internalType\":\"uint256\"},{\"name\":\"_basis\",\"type\":\"uint256\",\"internalType\":\"uint256\"},{\"name\":\"_trimValue\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"allowance\",\"inputs\":[{\"name\":\"owner\",\"type\":\"address\",\"internalType\":\"address\"},{\"name\":\"spender\",\"type\":\"address\",\"internalType\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"approve\",\"inputs\":[{\"name\":\"spender\",\"type\":\"address\",\"internalType\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\",\"internalType\":\"bool\"}],\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"balanceOf\",\"inputs\":[{\"name\":\"account\",\"type\":\"address\",\"internalType\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"basis\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"calculateDistributeAmount\",\"inputs\":[{\"name\":\"erc20Value\",\"type\":\"uint256\",\"internalType\":\"uint256\"},{\"name\":\"nativeValue\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"calculateWithdrawAmount\",\"inputs\":[{\"name\":\"amountIn\",\"type\":\"uint256\",\"internalType\":\"uint256\"},{\"name\":\"wantNative\",\"type\":\"bool\",\"internalType\":\"bool\"}],\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"dead\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\",\"internalType\":\"address\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"decimals\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint8\",\"internalType\":\"uint8\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"deposit\",\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"stateMutability\":\"payable\"},{\"type\":\"function\",\"name\":\"initialERC20Ratio\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"initialNativeRatio\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"name\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\",\"internalType\":\"string\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"swapNativeForToken\",\"inputs\":[],\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"stateMutability\":\"payable\"},{\"type\":\"function\",\"name\":\"swapTokenForNative\",\"inputs\":[{\"name\":\"amountIn\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"symbol\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\",\"internalType\":\"string\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"token\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\",\"internalType\":\"address\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"totalSupply\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"transfer\",\"inputs\":[{\"name\":\"to\",\"type\":\"address\",\"internalType\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\",\"internalType\":\"bool\"}],\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"transferFrom\",\"inputs\":[{\"name\":\"from\",\"type\":\"address\",\"internalType\":\"address\"},{\"name\":\"to\",\"type\":\"address\",\"internalType\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\",\"internalType\":\"bool\"}],\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"trimValue\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"withdraw\",\"inputs\":[{\"name\":\"amountIn\",\"type\":\"uint256\",\"internalType\":\"uint256\"},{\"name\":\"wantNative\",\"type\":\"bool\",\"internalType\":\"bool\"}],\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"stateMutability\":\"nonpayable\"},{\"type\":\"event\",\"name\":\"Approval\",\"inputs\":[{\"name\":\"owner\",\"type\":\"address\",\"indexed\":true,\"internalType\":\"address\"},{\"name\":\"spender\",\"type\":\"address\",\"indexed\":true,\"internalType\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\",\"indexed\":false,\"internalType\":\"uint256\"}],\"anonymous\":false},{\"type\":\"event\",\"name\":\"Transfer\",\"inputs\":[{\"name\":\"from\",\"type\":\"address\",\"indexed\":true,\"internalType\":\"address\"},{\"name\":\"to\",\"type\":\"address\",\"indexed\":true,\"internalType\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\",\"indexed\":false,\"internalType\":\"uint256\"}],\"anonymous\":false},{\"type\":\"error\",\"name\":\"AddressEmptyCode\",\"inputs\":[{\"name\":\"target\",\"type\":\"address\",\"internalType\":\"address\"}]},{\"type\":\"error\",\"name\":\"AddressInsufficientBalance\",\"inputs\":[{\"name\":\"account\",\"type\":\"address\",\"internalType\":\"address\"}]},{\"type\":\"error\",\"name\":\"ERC20InsufficientAllowance\",\"inputs\":[{\"name\":\"spender\",\"type\":\"address\",\"internalType\":\"address\"},{\"name\":\"allowance\",\"type\":\"uint256\",\"internalType\":\"uint256\"},{\"name\":\"needed\",\"type\":\"uint256\",\"internalType\":\"uint256\"}]},{\"type\":\"error\",\"name\":\"ERC20InsufficientBalance\",\"inputs\":[{\"name\":\"sender\",\"type\":\"address\",\"internalType\":\"address\"},{\"name\":\"balance\",\"type\":\"uint256\",\"internalType\":\"uint256\"},{\"name\":\"needed\",\"type\":\"uint256\",\"internalType\":\"uint256\"}]},{\"type\":\"error\",\"name\":\"ERC20InvalidApprover\",\"inputs\":[{\"name\":\"approver\",\"type\":\"address\",\"internalType\":\"address\"}]},{\"type\":\"error\",\"name\":\"ERC20InvalidReceiver\",\"inputs\":[{\"name\":\"receiver\",\"type\":\"address\",\"internalType\":\"address\"}]},{\"type\":\"error\",\"name\":\"ERC20InvalidSender\",\"inputs\":[{\"name\":\"sender\",\"type\":\"address\",\"internalType\":\"address\"}]},{\"type\":\"error\",\"name\":\"ERC20InvalidSpender\",\"inputs\":[{\"name\":\"spender\",\"type\":\"address\",\"internalType\":\"address\"}]},{\"type\":\"error\",\"name\":\"FailedInnerCall\",\"inputs\":[]},{\"type\":\"error\",\"name\":\"ReentrancyGuardReentrantCall\",\"inputs\":[]},{\"type\":\"error\",\"name\":\"SafeERC20FailedOperation\",\"inputs\":[{\"name\":\"token\",\"type\":\"address\",\"internalType\":\"address\"}]}]",
	Bin: "0x610120604052600680546001600160a01b03191661dead17905534801561002557600080fd5b50604051611a46380380611a468339810160408190526100449161019e565b8686600361005283826102d9565b50600461005f82826102d9565b5050600160058190556001600160a01b038716608052831190506100c95760405162461bcd60e51b815260206004820181905260248201527f4261736973206e6565647320746f2062652067726561746572207468616e2031604482015260640160405180910390fd5b60a0919091526101005260e09190915260c05250610397915050565b634e487b7160e01b600052604160045260246000fd5b600082601f83011261010c57600080fd5b81516001600160401b03811115610125576101256100e5565b604051601f8201601f19908116603f011681016001600160401b0381118282101715610153576101536100e5565b60405281815283820160200185101561016b57600080fd5b60005b8281101561018a5760208186018101518383018201520161016e565b506000918101602001919091529392505050565b600080600080600080600060e0888a0312156101b957600080fd5b87516001600160401b038111156101cf57600080fd5b6101db8a828b016100fb565b60208a015190985090506001600160401b038111156101f957600080fd5b6102058a828b016100fb565b60408a015190975090506001600160a01b038116811461022457600080fd5b606089015160808a015160a08b015160c0909b0151999c989b5091999098919790965090945092505050565b600181811c9082168061026457607f821691505b60208210810361028457634e487b7160e01b600052602260045260246000fd5b50919050565b601f8211156102d457806000526020600020601f840160051c810160208510156102b15750805b601f840160051c820191505b818110156102d157600081556001016102bd565b50505b505050565b81516001600160401b038111156102f2576102f26100e5565b610306816103008454610250565b8461028a565b6020601f82116001811461033a57600083156103225750848201515b600019600385901b1c1916600184901b1784556102d1565b600084815260208120601f198516915b8281101561036a578785015182556020948501946001909201910161034a565b50848210156103885786840151600019600387901b60f8161c191681555b50505050600190811b01905550565b60805160a05160c05160e051610100516115fb61044b6000396000818161030e01528181610eee0152610f290152600081816103bb01526106ee015260008181610217015261058301526000818161040f015281816107260152818161074f0152610e9e01526000818161044b015281816105c20152818161065001528181610855015281816108cd0152818161092e01528181610a8001528181610b1701528181610bab0152610c5601526115fb6000f3fe60806040526004361061012a5760003560e01c806395d89b41116100ab578063ebfc7a6a1161006f578063ebfc7a6a14610389578063f1de0e97146103a9578063f2b29a4e146103dd578063f385cecb146103fd578063f773ccab14610431578063fc0c546a1461043957600080fd5b806395d89b41146102c7578063a9059cbb146102dc578063ab1cc379146102fc578063b6b55f2514610330578063dd62ed3e1461034357600080fd5b8063313ce567116100f2578063313ce567146101e9578063367dc2691461020557806336cf7c871461023957806338d074361461027157806370a082311461029157600080fd5b806306fdde031461012f578063095ea7b31461015a57806318160ddd1461018a57806323b872dd146101a95780632d4bacbd146101c9575b600080fd5b34801561013b57600080fd5b5061014461046d565b604051610151919061134c565b60405180910390f35b34801561016657600080fd5b5061017a610175366004611396565b6104ff565b6040519015158152602001610151565b34801561019657600080fd5b506002545b604051908152602001610151565b3480156101b557600080fd5b5061017a6101c43660046113c0565b610519565b3480156101d557600080fd5b5061019b6101e43660046113fd565b61053f565b3480156101f557600080fd5b5060405160128152602001610151565b34801561021157600080fd5b5061019b7f000000000000000000000000000000000000000000000000000000000000000081565b34801561024557600080fd5b50600654610259906001600160a01b031681565b6040516001600160a01b039091168152602001610151565b34801561027d57600080fd5b5061019b61028c36600461142d565b610786565b34801561029d57600080fd5b5061019b6102ac36600461145d565b6001600160a01b031660009081526020819052604090205490565b3480156102d357600080fd5b50610144610886565b3480156102e857600080fd5b5061017a6102f7366004611396565b610895565b34801561030857600080fd5b5061019b7f000000000000000000000000000000000000000000000000000000000000000081565b61019b61033e366004611478565b6108a3565b34801561034f57600080fd5b5061019b61035e366004611491565b6001600160a01b03918216600090815260016020908152604080832093909416825291909152205490565b34801561039557600080fd5b5061019b6103a4366004611478565b610917565b3480156103b557600080fd5b5061019b7f000000000000000000000000000000000000000000000000000000000000000081565b3480156103e957600080fd5b5061019b6103f836600461142d565b610a02565b34801561040957600080fd5b5061019b7f000000000000000000000000000000000000000000000000000000000000000081565b61019b610c25565b34801561044557600080fd5b506102597f000000000000000000000000000000000000000000000000000000000000000081565b60606003805461047c906114c4565b80601f01602080910402602001604051908101604052809291908181526020018280546104a8906114c4565b80156104f55780601f106104ca576101008083540402835291602001916104f5565b820191906000526020600020905b8154815290600101906020018083116104d857829003601f168201915b5050505050905090565b60003361050d818585610c92565b60019150505b92915050565b600033610527858285610ca4565b610532858585610d22565b60019150505b9392505050565b600080600261054d60025490565b6105579190611514565b90508247111561057d574761056c8483611536565b6105769190611514565b91506105aa565b6105a7837f0000000000000000000000000000000000000000000000000000000000000000611536565b91505b6040516370a0823160e01b81523060048201526000907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316906370a0823190602401602060405180830381865afa158015610611573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610635919061154d565b11156106e8576040516370a0823160e01b81523060048201527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316906370a0823190602401602060405180830381865afa15801561069f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106c3919061154d565b6106cd8583611536565b6106d79190611514565b6106e19083611566565b915061071f565b610712847f0000000000000000000000000000000000000000000000000000000000000000611536565b61071c9083611566565b91505b61074a60017f0000000000000000000000000000000000000000000000000000000000000000611579565b6107747f000000000000000000000000000000000000000000000000000000000000000084611514565b61077e9190611536565b949350505050565b6000610790610d81565b61079a3384610dab565b6107a48383610a02565b9050811561084857604051600090339083908381818185875af1925050503d80600081146107ee576040519150601f19603f3d011682016040523d82523d6000602084013e6107f3565b606091505b50509050806108425760405162461bcd60e51b815260206004820152601660248201527513985d1a5d99481d1c985b9cd9995c8819985a5b195960521b60448201526064015b60405180910390fd5b5061087c565b61087c6001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000163383610de5565b6105136001600555565b60606004805461047c906114c4565b60003361050d818585610d22565b60006108ad610d81565b346108b8838261053f565b915082156108f5576108f56001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016333086610e44565b6108ff3383610e7d565b610907610ed1565b506109126001600555565b919050565b6000610921610d81565b6109566001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016333085610e44565b61096182600061053f565b905061096e816001610f54565b604051909150600090339083908381818185875af1925050503d80600081146109b3576040519150601f19603f3d011682016040523d82523d6000602084013e6109b8565b606091505b50509050806108ff5760405162461bcd60e51b815260206004820152601660248201527513985d1a5d99481d1c985b9cd9995c8819985a5b195960521b6044820152606401610839565b6000806002610a1060025490565b610a1a9190611514565b905080600003610a2d5760009150610c1e565b8215610a5f5780610a3e8547611536565b610a489190611514565b9150478211610a5757816106e1565b47915061071f565b6040516370a0823160e01b8152306004820152819085906001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016906370a0823190602401602060405180830381865afa158015610ac7573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610aeb919061154d565b610af59190611536565b610aff9190611514565b6040516370a0823160e01b81523060048201529092507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316906370a0823190602401602060405180830381865afa158015610b66573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b8a919061154d565b8211610b96578161071c565b6040516370a0823160e01b81523060048201527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316906370a0823190602401602060405180830381865afa158015610bfa573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061071c919061154d565b5092915050565b6000610c2f610d81565b610c3a60003461053f565b9050610c47816000610f54565b9050610c7d6001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000163383610de5565b610c85610ed1565b610c8f6001600555565b90565b610c9f8383836001610f86565b505050565b6001600160a01b038381166000908152600160209081526040808320938616835292905220546000198114610d1c5781811015610d0d57604051637dc7a0d960e11b81526001600160a01b03841660048201526024810182905260448101839052606401610839565b610d1c84848484036000610f86565b50505050565b6001600160a01b038316610d4c57604051634b637e8f60e11b815260006004820152602401610839565b6001600160a01b038216610d765760405163ec442f0560e01b815260006004820152602401610839565b610c9f83838361105b565b600260055403610da457604051633ee5aeb560e01b815260040160405180910390fd5b6002600555565b6001600160a01b038216610dd557604051634b637e8f60e11b815260006004820152602401610839565b610de18260008361105b565b5050565b6040516001600160a01b03838116602483015260448201839052610c9f91859182169063a9059cbb906064015b604051602081830303815290604052915060e01b6020820180516001600160e01b038381831617835250505050611185565b6040516001600160a01b038481166024830152838116604483015260648201839052610d1c9186918216906323b872dd90608401610e12565b610e8782826111e8565b600654610de1906001600160a01b0316610ec260017f0000000000000000000000000000000000000000000000000000000000000000611579565b610ecc9084611514565b6111e8565b6006546001600160a01b03166000908152602081905260409020547f000000000000000000000000000000000000000000000000000000000000000011610f5257600654610f52906001600160a01b0316610f4d60027f0000000000000000000000000000000000000000000000000000000000000000611514565b610dab565b565b6000610f603084610e7d565b610f6a8383610a02565b3060008181526020819052604090205491925061051391610dab565b6001600160a01b038416610fb05760405163e602df0560e01b815260006004820152602401610839565b6001600160a01b038316610fda57604051634a1406b160e11b815260006004820152602401610839565b6001600160a01b0380851660009081526001602090815260408083209387168352929052208290558015610d1c57826001600160a01b0316846001600160a01b03167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b9258460405161104d91815260200190565b60405180910390a350505050565b6001600160a01b03831661108657806002600082825461107b9190611566565b909155506110f89050565b6001600160a01b038316600090815260208190526040902054818110156110d95760405163391434e360e21b81526001600160a01b03851660048201526024810182905260448101839052606401610839565b6001600160a01b03841660009081526020819052604090209082900390555b6001600160a01b03821661111457600280548290039055611133565b6001600160a01b03821660009081526020819052604090208054820190555b816001600160a01b0316836001600160a01b03167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef8360405161117891815260200190565b60405180910390a3505050565b600061119a6001600160a01b0384168361121e565b905080516000141580156111bf5750808060200190518101906111bd919061158c565b155b15610c9f57604051635274afe760e01b81526001600160a01b0384166004820152602401610839565b6001600160a01b0382166112125760405163ec442f0560e01b815260006004820152602401610839565b610de16000838361105b565b60606105388383600084600080856001600160a01b0316848660405161124491906115a9565b60006040518083038185875af1925050503d8060008114611281576040519150601f19603f3d011682016040523d82523d6000602084013e611286565b606091505b50915091506112968683836112a0565b9695505050505050565b6060826112b5576112b0826112fc565b610538565b81511580156112cc57506001600160a01b0384163b155b156112f557604051639996b31560e01b81526001600160a01b0385166004820152602401610839565b5080610538565b80511561130c5780518082602001fd5b604051630a12f52160e11b815260040160405180910390fd5b50565b60005b8381101561134357818101518382015260200161132b565b50506000910152565b602081526000825180602084015261136b816040850160208701611328565b601f01601f19169190910160400192915050565b80356001600160a01b038116811461091257600080fd5b600080604083850312156113a957600080fd5b6113b28361137f565b946020939093013593505050565b6000806000606084860312156113d557600080fd5b6113de8461137f565b92506113ec6020850161137f565b929592945050506040919091013590565b6000806040838503121561141057600080fd5b50508035926020909101359150565b801515811461132557600080fd5b6000806040838503121561144057600080fd5b8235915060208301356114528161141f565b809150509250929050565b60006020828403121561146f57600080fd5b6105388261137f565b60006020828403121561148a57600080fd5b5035919050565b600080604083850312156114a457600080fd5b6114ad8361137f565b91506114bb6020840161137f565b90509250929050565b600181811c908216806114d857607f821691505b6020821081036114f857634e487b7160e01b600052602260045260246000fd5b50919050565b634e487b7160e01b600052601160045260246000fd5b60008261153157634e487b7160e01b600052601260045260246000fd5b500490565b8082028115828204841417610513576105136114fe565b60006020828403121561155f57600080fd5b5051919050565b80820180821115610513576105136114fe565b81810381811115610513576105136114fe565b60006020828403121561159e57600080fd5b81516105388161141f565b600082516115bb818460208701611328565b919091019291505056fea26469706673582212205db63154a35f2e51dbb0969f30aa4dcff0a3ab9cdf5b2d2367f828efe2f4e3f564736f6c634300081c0033",
}

// DualFiABI is the input ABI used to generate the binding from.
// Deprecated: Use DualFiMetaData.ABI instead.
var DualFiABI = DualFiMetaData.ABI

// DualFiBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use DualFiMetaData.Bin instead.
var DualFiBin = DualFiMetaData.Bin

// DeployDualFi deploys a new Ethereum contract, binding an instance of DualFi to it.
func DeployDualFi(auth *bind.TransactOpts, backend bind.ContractBackend, _name string, _symbol string, tokenA common.Address, initialAmount0Token *big.Int, initialAmountNative *big.Int, _basis *big.Int, _trimValue *big.Int) (common.Address, *types.Transaction, *DualFi, error) {
	parsed, err := DualFiMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(DualFiBin), backend, _name, _symbol, tokenA, initialAmount0Token, initialAmountNative, _basis, _trimValue)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &DualFi{DualFiCaller: DualFiCaller{contract: contract}, DualFiTransactor: DualFiTransactor{contract: contract}, DualFiFilterer: DualFiFilterer{contract: contract}}, nil
}

// DualFi is an auto generated Go binding around an Ethereum contract.
type DualFi struct {
	DualFiCaller     // Read-only binding to the contract
	DualFiTransactor // Write-only binding to the contract
	DualFiFilterer   // Log filterer for contract events
}

// DualFiCaller is an auto generated read-only Go binding around an Ethereum contract.
type DualFiCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// DualFiTransactor is an auto generated write-only Go binding around an Ethereum contract.
type DualFiTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// DualFiFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type DualFiFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// DualFiSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type DualFiSession struct {
	Contract     *DualFi           // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// DualFiCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type DualFiCallerSession struct {
	Contract *DualFiCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// DualFiTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type DualFiTransactorSession struct {
	Contract     *DualFiTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// DualFiRaw is an auto generated low-level Go binding around an Ethereum contract.
type DualFiRaw struct {
	Contract *DualFi // Generic contract binding to access the raw methods on
}

// DualFiCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type DualFiCallerRaw struct {
	Contract *DualFiCaller // Generic read-only contract binding to access the raw methods on
}

// DualFiTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type DualFiTransactorRaw struct {
	Contract *DualFiTransactor // Generic write-only contract binding to access the raw methods on
}

// NewDualFi creates a new instance of DualFi, bound to a specific deployed contract.
func NewDualFi(address common.Address, backend bind.ContractBackend) (*DualFi, error) {
	contract, err := bindDualFi(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &DualFi{DualFiCaller: DualFiCaller{contract: contract}, DualFiTransactor: DualFiTransactor{contract: contract}, DualFiFilterer: DualFiFilterer{contract: contract}}, nil
}

// NewDualFiCaller creates a new read-only instance of DualFi, bound to a specific deployed contract.
func NewDualFiCaller(address common.Address, caller bind.ContractCaller) (*DualFiCaller, error) {
	contract, err := bindDualFi(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &DualFiCaller{contract: contract}, nil
}

// NewDualFiTransactor creates a new write-only instance of DualFi, bound to a specific deployed contract.
func NewDualFiTransactor(address common.Address, transactor bind.ContractTransactor) (*DualFiTransactor, error) {
	contract, err := bindDualFi(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &DualFiTransactor{contract: contract}, nil
}

// NewDualFiFilterer creates a new log filterer instance of DualFi, bound to a specific deployed contract.
func NewDualFiFilterer(address common.Address, filterer bind.ContractFilterer) (*DualFiFilterer, error) {
	contract, err := bindDualFi(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &DualFiFilterer{contract: contract}, nil
}

// bindDualFi binds a generic wrapper to an already deployed contract.
func bindDualFi(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := DualFiMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_DualFi *DualFiRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _DualFi.Contract.DualFiCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_DualFi *DualFiRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _DualFi.Contract.DualFiTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_DualFi *DualFiRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _DualFi.Contract.DualFiTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_DualFi *DualFiCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _DualFi.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_DualFi *DualFiTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _DualFi.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_DualFi *DualFiTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _DualFi.Contract.contract.Transact(opts, method, params...)
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_DualFi *DualFiCaller) Allowance(opts *bind.CallOpts, owner common.Address, spender common.Address) (*big.Int, error) {
	var out []interface{}
	err := _DualFi.contract.Call(opts, &out, "allowance", owner, spender)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_DualFi *DualFiSession) Allowance(owner common.Address, spender common.Address) (*big.Int, error) {
	return _DualFi.Contract.Allowance(&_DualFi.CallOpts, owner, spender)
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_DualFi *DualFiCallerSession) Allowance(owner common.Address, spender common.Address) (*big.Int, error) {
	return _DualFi.Contract.Allowance(&_DualFi.CallOpts, owner, spender)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_DualFi *DualFiCaller) BalanceOf(opts *bind.CallOpts, account common.Address) (*big.Int, error) {
	var out []interface{}
	err := _DualFi.contract.Call(opts, &out, "balanceOf", account)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_DualFi *DualFiSession) BalanceOf(account common.Address) (*big.Int, error) {
	return _DualFi.Contract.BalanceOf(&_DualFi.CallOpts, account)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_DualFi *DualFiCallerSession) BalanceOf(account common.Address) (*big.Int, error) {
	return _DualFi.Contract.BalanceOf(&_DualFi.CallOpts, account)
}

// Basis is a free data retrieval call binding the contract method 0xf385cecb.
//
// Solidity: function basis() view returns(uint256)
func (_DualFi *DualFiCaller) Basis(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _DualFi.contract.Call(opts, &out, "basis")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// Basis is a free data retrieval call binding the contract method 0xf385cecb.
//
// Solidity: function basis() view returns(uint256)
func (_DualFi *DualFiSession) Basis() (*big.Int, error) {
	return _DualFi.Contract.Basis(&_DualFi.CallOpts)
}

// Basis is a free data retrieval call binding the contract method 0xf385cecb.
//
// Solidity: function basis() view returns(uint256)
func (_DualFi *DualFiCallerSession) Basis() (*big.Int, error) {
	return _DualFi.Contract.Basis(&_DualFi.CallOpts)
}

// CalculateDistributeAmount is a free data retrieval call binding the contract method 0x2d4bacbd.
//
// Solidity: function calculateDistributeAmount(uint256 erc20Value, uint256 nativeValue) view returns(uint256 amount)
func (_DualFi *DualFiCaller) CalculateDistributeAmount(opts *bind.CallOpts, erc20Value *big.Int, nativeValue *big.Int) (*big.Int, error) {
	var out []interface{}
	err := _DualFi.contract.Call(opts, &out, "calculateDistributeAmount", erc20Value, nativeValue)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// CalculateDistributeAmount is a free data retrieval call binding the contract method 0x2d4bacbd.
//
// Solidity: function calculateDistributeAmount(uint256 erc20Value, uint256 nativeValue) view returns(uint256 amount)
func (_DualFi *DualFiSession) CalculateDistributeAmount(erc20Value *big.Int, nativeValue *big.Int) (*big.Int, error) {
	return _DualFi.Contract.CalculateDistributeAmount(&_DualFi.CallOpts, erc20Value, nativeValue)
}

// CalculateDistributeAmount is a free data retrieval call binding the contract method 0x2d4bacbd.
//
// Solidity: function calculateDistributeAmount(uint256 erc20Value, uint256 nativeValue) view returns(uint256 amount)
func (_DualFi *DualFiCallerSession) CalculateDistributeAmount(erc20Value *big.Int, nativeValue *big.Int) (*big.Int, error) {
	return _DualFi.Contract.CalculateDistributeAmount(&_DualFi.CallOpts, erc20Value, nativeValue)
}

// CalculateWithdrawAmount is a free data retrieval call binding the contract method 0xf2b29a4e.
//
// Solidity: function calculateWithdrawAmount(uint256 amountIn, bool wantNative) view returns(uint256 amount)
func (_DualFi *DualFiCaller) CalculateWithdrawAmount(opts *bind.CallOpts, amountIn *big.Int, wantNative bool) (*big.Int, error) {
	var out []interface{}
	err := _DualFi.contract.Call(opts, &out, "calculateWithdrawAmount", amountIn, wantNative)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// CalculateWithdrawAmount is a free data retrieval call binding the contract method 0xf2b29a4e.
//
// Solidity: function calculateWithdrawAmount(uint256 amountIn, bool wantNative) view returns(uint256 amount)
func (_DualFi *DualFiSession) CalculateWithdrawAmount(amountIn *big.Int, wantNative bool) (*big.Int, error) {
	return _DualFi.Contract.CalculateWithdrawAmount(&_DualFi.CallOpts, amountIn, wantNative)
}

// CalculateWithdrawAmount is a free data retrieval call binding the contract method 0xf2b29a4e.
//
// Solidity: function calculateWithdrawAmount(uint256 amountIn, bool wantNative) view returns(uint256 amount)
func (_DualFi *DualFiCallerSession) CalculateWithdrawAmount(amountIn *big.Int, wantNative bool) (*big.Int, error) {
	return _DualFi.Contract.CalculateWithdrawAmount(&_DualFi.CallOpts, amountIn, wantNative)
}

// Dead is a free data retrieval call binding the contract method 0x36cf7c87.
//
// Solidity: function dead() view returns(address)
func (_DualFi *DualFiCaller) Dead(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _DualFi.contract.Call(opts, &out, "dead")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Dead is a free data retrieval call binding the contract method 0x36cf7c87.
//
// Solidity: function dead() view returns(address)
func (_DualFi *DualFiSession) Dead() (common.Address, error) {
	return _DualFi.Contract.Dead(&_DualFi.CallOpts)
}

// Dead is a free data retrieval call binding the contract method 0x36cf7c87.
//
// Solidity: function dead() view returns(address)
func (_DualFi *DualFiCallerSession) Dead() (common.Address, error) {
	return _DualFi.Contract.Dead(&_DualFi.CallOpts)
}

// Decimals is a free data retrieval call binding the contract method 0x313ce567.
//
// Solidity: function decimals() view returns(uint8)
func (_DualFi *DualFiCaller) Decimals(opts *bind.CallOpts) (uint8, error) {
	var out []interface{}
	err := _DualFi.contract.Call(opts, &out, "decimals")

	if err != nil {
		return *new(uint8), err
	}

	out0 := *abi.ConvertType(out[0], new(uint8)).(*uint8)

	return out0, err

}

// Decimals is a free data retrieval call binding the contract method 0x313ce567.
//
// Solidity: function decimals() view returns(uint8)
func (_DualFi *DualFiSession) Decimals() (uint8, error) {
	return _DualFi.Contract.Decimals(&_DualFi.CallOpts)
}

// Decimals is a free data retrieval call binding the contract method 0x313ce567.
//
// Solidity: function decimals() view returns(uint8)
func (_DualFi *DualFiCallerSession) Decimals() (uint8, error) {
	return _DualFi.Contract.Decimals(&_DualFi.CallOpts)
}

// InitialERC20Ratio is a free data retrieval call binding the contract method 0xf1de0e97.
//
// Solidity: function initialERC20Ratio() view returns(uint256)
func (_DualFi *DualFiCaller) InitialERC20Ratio(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _DualFi.contract.Call(opts, &out, "initialERC20Ratio")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// InitialERC20Ratio is a free data retrieval call binding the contract method 0xf1de0e97.
//
// Solidity: function initialERC20Ratio() view returns(uint256)
func (_DualFi *DualFiSession) InitialERC20Ratio() (*big.Int, error) {
	return _DualFi.Contract.InitialERC20Ratio(&_DualFi.CallOpts)
}

// InitialERC20Ratio is a free data retrieval call binding the contract method 0xf1de0e97.
//
// Solidity: function initialERC20Ratio() view returns(uint256)
func (_DualFi *DualFiCallerSession) InitialERC20Ratio() (*big.Int, error) {
	return _DualFi.Contract.InitialERC20Ratio(&_DualFi.CallOpts)
}

// InitialNativeRatio is a free data retrieval call binding the contract method 0x367dc269.
//
// Solidity: function initialNativeRatio() view returns(uint256)
func (_DualFi *DualFiCaller) InitialNativeRatio(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _DualFi.contract.Call(opts, &out, "initialNativeRatio")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// InitialNativeRatio is a free data retrieval call binding the contract method 0x367dc269.
//
// Solidity: function initialNativeRatio() view returns(uint256)
func (_DualFi *DualFiSession) InitialNativeRatio() (*big.Int, error) {
	return _DualFi.Contract.InitialNativeRatio(&_DualFi.CallOpts)
}

// InitialNativeRatio is a free data retrieval call binding the contract method 0x367dc269.
//
// Solidity: function initialNativeRatio() view returns(uint256)
func (_DualFi *DualFiCallerSession) InitialNativeRatio() (*big.Int, error) {
	return _DualFi.Contract.InitialNativeRatio(&_DualFi.CallOpts)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_DualFi *DualFiCaller) Name(opts *bind.CallOpts) (string, error) {
	var out []interface{}
	err := _DualFi.contract.Call(opts, &out, "name")

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_DualFi *DualFiSession) Name() (string, error) {
	return _DualFi.Contract.Name(&_DualFi.CallOpts)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_DualFi *DualFiCallerSession) Name() (string, error) {
	return _DualFi.Contract.Name(&_DualFi.CallOpts)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_DualFi *DualFiCaller) Symbol(opts *bind.CallOpts) (string, error) {
	var out []interface{}
	err := _DualFi.contract.Call(opts, &out, "symbol")

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_DualFi *DualFiSession) Symbol() (string, error) {
	return _DualFi.Contract.Symbol(&_DualFi.CallOpts)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_DualFi *DualFiCallerSession) Symbol() (string, error) {
	return _DualFi.Contract.Symbol(&_DualFi.CallOpts)
}

// Token is a free data retrieval call binding the contract method 0xfc0c546a.
//
// Solidity: function token() view returns(address)
func (_DualFi *DualFiCaller) Token(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _DualFi.contract.Call(opts, &out, "token")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Token is a free data retrieval call binding the contract method 0xfc0c546a.
//
// Solidity: function token() view returns(address)
func (_DualFi *DualFiSession) Token() (common.Address, error) {
	return _DualFi.Contract.Token(&_DualFi.CallOpts)
}

// Token is a free data retrieval call binding the contract method 0xfc0c546a.
//
// Solidity: function token() view returns(address)
func (_DualFi *DualFiCallerSession) Token() (common.Address, error) {
	return _DualFi.Contract.Token(&_DualFi.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_DualFi *DualFiCaller) TotalSupply(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _DualFi.contract.Call(opts, &out, "totalSupply")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_DualFi *DualFiSession) TotalSupply() (*big.Int, error) {
	return _DualFi.Contract.TotalSupply(&_DualFi.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_DualFi *DualFiCallerSession) TotalSupply() (*big.Int, error) {
	return _DualFi.Contract.TotalSupply(&_DualFi.CallOpts)
}

// TrimValue is a free data retrieval call binding the contract method 0xab1cc379.
//
// Solidity: function trimValue() view returns(uint256)
func (_DualFi *DualFiCaller) TrimValue(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _DualFi.contract.Call(opts, &out, "trimValue")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// TrimValue is a free data retrieval call binding the contract method 0xab1cc379.
//
// Solidity: function trimValue() view returns(uint256)
func (_DualFi *DualFiSession) TrimValue() (*big.Int, error) {
	return _DualFi.Contract.TrimValue(&_DualFi.CallOpts)
}

// TrimValue is a free data retrieval call binding the contract method 0xab1cc379.
//
// Solidity: function trimValue() view returns(uint256)
func (_DualFi *DualFiCallerSession) TrimValue() (*big.Int, error) {
	return _DualFi.Contract.TrimValue(&_DualFi.CallOpts)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 value) returns(bool)
func (_DualFi *DualFiTransactor) Approve(opts *bind.TransactOpts, spender common.Address, value *big.Int) (*types.Transaction, error) {
	return _DualFi.contract.Transact(opts, "approve", spender, value)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 value) returns(bool)
func (_DualFi *DualFiSession) Approve(spender common.Address, value *big.Int) (*types.Transaction, error) {
	return _DualFi.Contract.Approve(&_DualFi.TransactOpts, spender, value)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 value) returns(bool)
func (_DualFi *DualFiTransactorSession) Approve(spender common.Address, value *big.Int) (*types.Transaction, error) {
	return _DualFi.Contract.Approve(&_DualFi.TransactOpts, spender, value)
}

// Deposit is a paid mutator transaction binding the contract method 0xb6b55f25.
//
// Solidity: function deposit(uint256 value) payable returns(uint256 amount)
func (_DualFi *DualFiTransactor) Deposit(opts *bind.TransactOpts, value *big.Int) (*types.Transaction, error) {
	return _DualFi.contract.Transact(opts, "deposit", value)
}

// Deposit is a paid mutator transaction binding the contract method 0xb6b55f25.
//
// Solidity: function deposit(uint256 value) payable returns(uint256 amount)
func (_DualFi *DualFiSession) Deposit(value *big.Int) (*types.Transaction, error) {
	return _DualFi.Contract.Deposit(&_DualFi.TransactOpts, value)
}

// Deposit is a paid mutator transaction binding the contract method 0xb6b55f25.
//
// Solidity: function deposit(uint256 value) payable returns(uint256 amount)
func (_DualFi *DualFiTransactorSession) Deposit(value *big.Int) (*types.Transaction, error) {
	return _DualFi.Contract.Deposit(&_DualFi.TransactOpts, value)
}

// SwapNativeForToken is a paid mutator transaction binding the contract method 0xf773ccab.
//
// Solidity: function swapNativeForToken() payable returns(uint256 amount)
func (_DualFi *DualFiTransactor) SwapNativeForToken(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _DualFi.contract.Transact(opts, "swapNativeForToken")
}

// SwapNativeForToken is a paid mutator transaction binding the contract method 0xf773ccab.
//
// Solidity: function swapNativeForToken() payable returns(uint256 amount)
func (_DualFi *DualFiSession) SwapNativeForToken() (*types.Transaction, error) {
	return _DualFi.Contract.SwapNativeForToken(&_DualFi.TransactOpts)
}

// SwapNativeForToken is a paid mutator transaction binding the contract method 0xf773ccab.
//
// Solidity: function swapNativeForToken() payable returns(uint256 amount)
func (_DualFi *DualFiTransactorSession) SwapNativeForToken() (*types.Transaction, error) {
	return _DualFi.Contract.SwapNativeForToken(&_DualFi.TransactOpts)
}

// SwapTokenForNative is a paid mutator transaction binding the contract method 0xebfc7a6a.
//
// Solidity: function swapTokenForNative(uint256 amountIn) returns(uint256 amount)
func (_DualFi *DualFiTransactor) SwapTokenForNative(opts *bind.TransactOpts, amountIn *big.Int) (*types.Transaction, error) {
	return _DualFi.contract.Transact(opts, "swapTokenForNative", amountIn)
}

// SwapTokenForNative is a paid mutator transaction binding the contract method 0xebfc7a6a.
//
// Solidity: function swapTokenForNative(uint256 amountIn) returns(uint256 amount)
func (_DualFi *DualFiSession) SwapTokenForNative(amountIn *big.Int) (*types.Transaction, error) {
	return _DualFi.Contract.SwapTokenForNative(&_DualFi.TransactOpts, amountIn)
}

// SwapTokenForNative is a paid mutator transaction binding the contract method 0xebfc7a6a.
//
// Solidity: function swapTokenForNative(uint256 amountIn) returns(uint256 amount)
func (_DualFi *DualFiTransactorSession) SwapTokenForNative(amountIn *big.Int) (*types.Transaction, error) {
	return _DualFi.Contract.SwapTokenForNative(&_DualFi.TransactOpts, amountIn)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 value) returns(bool)
func (_DualFi *DualFiTransactor) Transfer(opts *bind.TransactOpts, to common.Address, value *big.Int) (*types.Transaction, error) {
	return _DualFi.contract.Transact(opts, "transfer", to, value)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 value) returns(bool)
func (_DualFi *DualFiSession) Transfer(to common.Address, value *big.Int) (*types.Transaction, error) {
	return _DualFi.Contract.Transfer(&_DualFi.TransactOpts, to, value)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 value) returns(bool)
func (_DualFi *DualFiTransactorSession) Transfer(to common.Address, value *big.Int) (*types.Transaction, error) {
	return _DualFi.Contract.Transfer(&_DualFi.TransactOpts, to, value)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 value) returns(bool)
func (_DualFi *DualFiTransactor) TransferFrom(opts *bind.TransactOpts, from common.Address, to common.Address, value *big.Int) (*types.Transaction, error) {
	return _DualFi.contract.Transact(opts, "transferFrom", from, to, value)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 value) returns(bool)
func (_DualFi *DualFiSession) TransferFrom(from common.Address, to common.Address, value *big.Int) (*types.Transaction, error) {
	return _DualFi.Contract.TransferFrom(&_DualFi.TransactOpts, from, to, value)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 value) returns(bool)
func (_DualFi *DualFiTransactorSession) TransferFrom(from common.Address, to common.Address, value *big.Int) (*types.Transaction, error) {
	return _DualFi.Contract.TransferFrom(&_DualFi.TransactOpts, from, to, value)
}

// Withdraw is a paid mutator transaction binding the contract method 0x38d07436.
//
// Solidity: function withdraw(uint256 amountIn, bool wantNative) returns(uint256 amount)
func (_DualFi *DualFiTransactor) Withdraw(opts *bind.TransactOpts, amountIn *big.Int, wantNative bool) (*types.Transaction, error) {
	return _DualFi.contract.Transact(opts, "withdraw", amountIn, wantNative)
}

// Withdraw is a paid mutator transaction binding the contract method 0x38d07436.
//
// Solidity: function withdraw(uint256 amountIn, bool wantNative) returns(uint256 amount)
func (_DualFi *DualFiSession) Withdraw(amountIn *big.Int, wantNative bool) (*types.Transaction, error) {
	return _DualFi.Contract.Withdraw(&_DualFi.TransactOpts, amountIn, wantNative)
}

// Withdraw is a paid mutator transaction binding the contract method 0x38d07436.
//
// Solidity: function withdraw(uint256 amountIn, bool wantNative) returns(uint256 amount)
func (_DualFi *DualFiTransactorSession) Withdraw(amountIn *big.Int, wantNative bool) (*types.Transaction, error) {
	return _DualFi.Contract.Withdraw(&_DualFi.TransactOpts, amountIn, wantNative)
}

// DualFiApprovalIterator is returned from FilterApproval and is used to iterate over the raw logs and unpacked data for Approval events raised by the DualFi contract.
type DualFiApprovalIterator struct {
	Event *DualFiApproval // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *DualFiApprovalIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(DualFiApproval)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(DualFiApproval)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *DualFiApprovalIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *DualFiApprovalIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// DualFiApproval represents a Approval event raised by the DualFi contract.
type DualFiApproval struct {
	Owner   common.Address
	Spender common.Address
	Value   *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterApproval is a free log retrieval operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_DualFi *DualFiFilterer) FilterApproval(opts *bind.FilterOpts, owner []common.Address, spender []common.Address) (*DualFiApprovalIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var spenderRule []interface{}
	for _, spenderItem := range spender {
		spenderRule = append(spenderRule, spenderItem)
	}

	logs, sub, err := _DualFi.contract.FilterLogs(opts, "Approval", ownerRule, spenderRule)
	if err != nil {
		return nil, err
	}
	return &DualFiApprovalIterator{contract: _DualFi.contract, event: "Approval", logs: logs, sub: sub}, nil
}

// WatchApproval is a free log subscription operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_DualFi *DualFiFilterer) WatchApproval(opts *bind.WatchOpts, sink chan<- *DualFiApproval, owner []common.Address, spender []common.Address) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var spenderRule []interface{}
	for _, spenderItem := range spender {
		spenderRule = append(spenderRule, spenderItem)
	}

	logs, sub, err := _DualFi.contract.WatchLogs(opts, "Approval", ownerRule, spenderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(DualFiApproval)
				if err := _DualFi.contract.UnpackLog(event, "Approval", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApproval is a log parse operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_DualFi *DualFiFilterer) ParseApproval(log types.Log) (*DualFiApproval, error) {
	event := new(DualFiApproval)
	if err := _DualFi.contract.UnpackLog(event, "Approval", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// DualFiTransferIterator is returned from FilterTransfer and is used to iterate over the raw logs and unpacked data for Transfer events raised by the DualFi contract.
type DualFiTransferIterator struct {
	Event *DualFiTransfer // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *DualFiTransferIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(DualFiTransfer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(DualFiTransfer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *DualFiTransferIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *DualFiTransferIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// DualFiTransfer represents a Transfer event raised by the DualFi contract.
type DualFiTransfer struct {
	From  common.Address
	To    common.Address
	Value *big.Int
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterTransfer is a free log retrieval operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_DualFi *DualFiFilterer) FilterTransfer(opts *bind.FilterOpts, from []common.Address, to []common.Address) (*DualFiTransferIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _DualFi.contract.FilterLogs(opts, "Transfer", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return &DualFiTransferIterator{contract: _DualFi.contract, event: "Transfer", logs: logs, sub: sub}, nil
}

// WatchTransfer is a free log subscription operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_DualFi *DualFiFilterer) WatchTransfer(opts *bind.WatchOpts, sink chan<- *DualFiTransfer, from []common.Address, to []common.Address) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _DualFi.contract.WatchLogs(opts, "Transfer", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(DualFiTransfer)
				if err := _DualFi.contract.UnpackLog(event, "Transfer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTransfer is a log parse operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_DualFi *DualFiFilterer) ParseTransfer(log types.Log) (*DualFiTransfer, error) {
	event := new(DualFiTransfer)
	if err := _DualFi.contract.UnpackLog(event, "Transfer", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

func CreateDualFiDeploymentCommand() *cobra.Command {
	var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc string
	var gasLimit uint64
	var simulate bool
	var timeout uint
	var safeAddress, safeApi, safeCreateCall, safeSaltRaw, safeNonceRaw string
	var safeOperationType uint8
	var salt [32]byte
	var predictAddress bool
	var safeNonce *big.Int
	var calldata bool
	var verify bool
	var apiURL, apiKey string
	var runs uint
	var evmVersion, compilerVersion string

	var _name0 string

	var symbol string

	var tokenA common.Address
	var tokenARaw string
	var initialAmount0Token *big.Int
	var initialAmount0TokenRaw string
	var initialAmountNative *big.Int
	var initialAmountNativeRaw string
	var basis *big.Int
	var basisRaw string
	var trimValue *big.Int
	var trimValueRaw string

	cmd := &cobra.Command{
		Use:   "deploy",
		Short: "Deploy a new DualFi contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {

			if !calldata {
				if keyfile == "" {
					return fmt.Errorf("--keystore not specified (this should be a path to an Ethereum account keystore file)")
				}

				if rpc == "" {
					return fmt.Errorf("--rpc not specified (this should be a URL to an Ethereum JSONRPC API)")
				}
			}

			if safeAddress != "" {
				if !common.IsHexAddress(safeAddress) {
					return fmt.Errorf("--safe is not a valid Ethereum address")
				}
				if safeApi == "" {
					client, clientErr := NewClient(rpc)
					if clientErr != nil {
						return clientErr
					}
					chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
					defer cancelChainIDCtx()
					chainID, chainIDErr := client.ChainID(chainIDCtx)
					if chainIDErr != nil {
						return chainIDErr
					}
					safeApi = fmt.Sprintf("https://safe-client.safe.global/v1/chains/%s/transactions/%s/propose", chainID.String(), safeAddress)
					fmt.Println("--safe-api not specified, using default (", safeApi, ")")
				}

				if safeCreateCall == "" {
					fmt.Println("--safe-create-call not specified, using default (0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4)")
					safeCreateCall = "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4"
				}
				if !common.IsHexAddress(safeCreateCall) {
					return fmt.Errorf("--safe-create-call is not a valid Ethereum address")
				}

				if SafeOperationType(safeOperationType).String() == "Unknown" {
					return fmt.Errorf("--safe-operation must be 0 (Call) or 1 (DelegateCall)")
				}

				if safeSaltRaw == "" {
					fmt.Println("--safe-salt not specified, generating random salt")
					_, err := rand.Read(salt[:])
					if err != nil {
						return fmt.Errorf("failed to generate random salt: %v", err)
					}
					// prompt user to accept random salt
					fmt.Println("Generated salt:", common.Bytes2Hex(salt[:]))
					fmt.Println("Please check the salt and confirm (y/n)")
					var confirm string
					fmt.Scanln(&confirm)
					if confirm != "y" && confirm != "Y" && confirm != "\n" && confirm != "" {
						return fmt.Errorf("salt not accepted, please specify a valid salt")
					}
				} else {
					copy(salt[:], safeSaltRaw)
				}

				if safeNonceRaw == "" {
					fmt.Println("--safe-nonce not specified, fetching nonce from Safe contract")
				} else {
					safeNonce = new(big.Int)
					_, ok := safeNonce.SetString(safeNonceRaw, 0)
					if !ok {
						return fmt.Errorf("--safe-nonce is not a valid big integer")
					}
				}
			}

			if verify {
				if DualFiContractCode == "" {
					return fmt.Errorf("Cannot use --verify flag when contract code is empty, please re-run evm generate passing the --source-code flag")
				}

				if apiURL == "" {
					return fmt.Errorf("--api not specified")
				}
				if apiKey == "" {
					return fmt.Errorf("--api-key not specified")
				}
			}

			if tokenARaw == "" {
				return fmt.Errorf("--token-a argument not specified")
			} else if !common.IsHexAddress(tokenARaw) {
				return fmt.Errorf("--token-a argument is not a valid Ethereum address")
			}
			tokenA = common.HexToAddress(tokenARaw)

			if initialAmount0TokenRaw == "" {
				return fmt.Errorf("--initial-amount-0-token argument not specified")
			}
			initialAmount0Token = new(big.Int)
			initialAmount0Token.SetString(initialAmount0TokenRaw, 0)

			if initialAmountNativeRaw == "" {
				return fmt.Errorf("--initial-amount-native argument not specified")
			}
			initialAmountNative = new(big.Int)
			initialAmountNative.SetString(initialAmountNativeRaw, 0)

			if basisRaw == "" {
				return fmt.Errorf("--basis argument not specified")
			}
			basis = new(big.Int)
			basis.SetString(basisRaw, 0)

			if trimValueRaw == "" {
				return fmt.Errorf("--trim-value argument not specified")
			}
			trimValue = new(big.Int)
			trimValue.SetString(trimValueRaw, 0)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			// Generate deploy bytecode with constructor arguments
			deployCalldata, err := generateDualFiDeployBytecode(
				_name0,
				symbol,
				tokenA,
				initialAmount0Token,
				initialAmountNative,
				basis,
				trimValue,
			)
			if err != nil {
				return fmt.Errorf("failed to generate deploy bytecode: %v", err)
			}
			if calldata {
				deployCalldataHex := hex.EncodeToString(deployCalldata)
				cmd.Println(deployCalldataHex)
				return nil
			}

			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			key, keyErr := KeyFromFile(keyfile, password)
			if keyErr != nil {
				return keyErr
			}

			chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
			defer cancelChainIDCtx()
			chainID, chainIDErr := client.ChainID(chainIDCtx)
			if chainIDErr != nil {
				return chainIDErr
			}

			transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
			if transactionOptsErr != nil {
				return transactionOptsErr
			}

			SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

			if safeAddress != "" {
				// Create Safe proposal for deployment
				value := transactionOpts.Value
				if value == nil {
					value = big.NewInt(0)
				}

				if predictAddress {
					fmt.Println("Predicting deployment address...")
					from := common.HexToAddress(safeAddress)
					if safeOperationType == 0 {
						from = common.HexToAddress(safeCreateCall)
					}
					deploymentAddress, err := PredictDeploymentAddressSafe(from, salt, deployCalldata)
					if err != nil {
						return fmt.Errorf("failed to predict deployment address: %v", err)
					}
					fmt.Println("Predicted deployment address:", deploymentAddress.Hex())
					return nil
				} else {
					fmt.Println("Creating Safe proposal...")
					err = DeployWithSafe(client, key, common.HexToAddress(safeAddress), common.HexToAddress(safeCreateCall), value, safeApi, deployCalldata, SafeOperationType(safeOperationType), salt, safeNonce)
					if err != nil {
						return fmt.Errorf("failed to create Safe proposal: %v", err)
					}
				}

				return nil
			}

			address, deploymentTransaction, _, deploymentErr := DeployDualFi(
				transactionOpts,
				client,
				_name0,
				symbol,
				tokenA,
				initialAmount0Token,
				initialAmountNative,
				basis,
				trimValue,
			)
			if deploymentErr != nil {
				return deploymentErr
			}

			cmd.Printf("Transaction hash: %s\nContract address: %s\n", deploymentTransaction.Hash().Hex(), address.Hex())
			if transactionOpts.NoSend {
				estimationMessage := ethereum.CallMsg{
					From: transactionOpts.From,
					Data: deploymentTransaction.Data(),
				}

				gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
				defer cancelGasEstimationCtx()

				gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
				if gasEstimateErr != nil {
					return gasEstimateErr
				}

				transactionBinary, transactionBinaryErr := deploymentTransaction.MarshalBinary()
				if transactionBinaryErr != nil {
					return transactionBinaryErr
				}
				transactionBinaryHex := hex.EncodeToString(transactionBinary)

				cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
			} else {
				cmd.Println("Transaction submitted")
			}

			if verify {
				compilerInfo, err := ExtractCompilerInfo(DualFiBin)
				if err != nil {
					return fmt.Errorf("failed to extract compiler info: %v", err)
				}

				if compilerVersion != "" {
					compilerInfo.SolidityVersion = compilerVersion
				}
				if evmVersion != "" {
					compilerInfo.EVMVersion = evmVersion
				}

				err = VerifyContractCode(address, DualFiContractCode, apiURL, apiKey, "DualFi", compilerInfo.SolidityVersion, runs, compilerInfo.EVMVersion, _name0, symbol, tokenA, initialAmount0Token, initialAmountNative, basis, trimValue)
				if err != nil {
					fmt.Println("Failed to verify contract code:", err)
				} else {
					fmt.Println("Contract code verified successfully")
				}
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
	cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
	cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
	cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
	cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
	cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
	cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&safeAddress, "safe", "", "Address of the Safe contract")
	cmd.Flags().StringVar(&safeApi, "safe-api", "", "Safe API for the Safe Transaction Service (optional)")
	cmd.Flags().StringVar(&safeCreateCall, "safe-create-call", "", "Address of the CreateCall contract (optional)")
	cmd.Flags().Uint8Var(&safeOperationType, "safe-operation", 1, "Safe operation type: 0 (Call) or 1 (DelegateCall) - default is 1")
	cmd.Flags().StringVar(&safeSaltRaw, "safe-salt", "", "Salt to use for the Safe transaction")
	cmd.Flags().BoolVar(&predictAddress, "safe-predict-address", false, "Predict the deployment address (only works for Safe transactions)")
	cmd.Flags().StringVar(&safeNonceRaw, "safe-nonce", "", "Safe nonce overrider for the transaction (optional)")
	cmd.Flags().BoolVar(&calldata, "calldata", false, "Set this flag if want to return the calldata instead of sending the transaction")
	cmd.Flags().BoolVar(&verify, "verify", false, "Verify the contract code on a block explorer")
	cmd.Flags().StringVar(&apiURL, "api", "", "Block explorer API URL")
	cmd.Flags().StringVar(&apiKey, "api-key", "", "Block explorer API key")
	cmd.Flags().UintVar(&runs, "runs", 0, "The number of runs to use for optimization")
	cmd.Flags().StringVar(&evmVersion, "evm-version", "", "Override the EVM version to use for the contract")
	cmd.Flags().StringVar(&compilerVersion, "compiler-version", "", "Override the compiler version to use for the contract")

	cmd.Flags().StringVar(&_name0, "-name-0", "", "-name-0 argument")
	cmd.Flags().StringVar(&symbol, "symbol", "", "symbol argument")
	cmd.Flags().StringVar(&tokenARaw, "token-a", "", "token-a argument (common.Address)")
	cmd.Flags().StringVar(&initialAmount0TokenRaw, "initial-amount-0-token", "", "initial-amount-0-token argument")
	cmd.Flags().StringVar(&initialAmountNativeRaw, "initial-amount-native", "", "initial-amount-native argument")
	cmd.Flags().StringVar(&basisRaw, "basis", "", "basis argument")
	cmd.Flags().StringVar(&trimValueRaw, "trim-value", "", "trim-value argument")

	return cmd
}

func generateDualFiDeployBytecode(
	_name0 string,
	symbol string,
	tokenA common.Address,
	initialAmount0Token *big.Int,
	initialAmountNative *big.Int,
	basis *big.Int,
	trimValue *big.Int,
) ([]byte, error) {
	abiPacked, err := DualFiMetaData.GetAbi()
	if err != nil {
		return nil, fmt.Errorf("failed to get ABI: %v", err)
	}

	constructorArguments, err := abiPacked.Pack("",
		_name0,
		symbol,
		tokenA,
		initialAmount0Token,
		initialAmountNative,
		basis,
		trimValue,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to pack constructor arguments: %v", err)
	}

	deployBytecode := append(common.FromHex(DualFiMetaData.Bin), constructorArguments...)
	return deployBytecode, nil
}

func CreateAllowanceCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var owner common.Address
	var ownerRaw string
	var spender common.Address
	var spenderRaw string

	var capture0 *big.Int

	cmd := &cobra.Command{
		Use:   "allowance",
		Short: "Call the Allowance view method on a DualFi contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			if ownerRaw == "" {
				return fmt.Errorf("--owner argument not specified")
			} else if !common.IsHexAddress(ownerRaw) {
				return fmt.Errorf("--owner argument is not a valid Ethereum address")
			}
			owner = common.HexToAddress(ownerRaw)

			if spenderRaw == "" {
				return fmt.Errorf("--spender argument not specified")
			} else if !common.IsHexAddress(spenderRaw) {
				return fmt.Errorf("--spender argument is not a valid Ethereum address")
			}
			spender = common.HexToAddress(spenderRaw)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewDualFi(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := DualFiCallerSession{
				Contract: &contract.DualFiCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.Allowance(
				owner,
				spender,
			)
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %s\n", capture0.String())

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	cmd.Flags().StringVar(&ownerRaw, "owner", "", "owner argument (common.Address)")
	cmd.Flags().StringVar(&spenderRaw, "spender", "", "spender argument (common.Address)")

	return cmd
}
func CreateBalanceOfCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var account common.Address
	var accountRaw string

	var capture0 *big.Int

	cmd := &cobra.Command{
		Use:   "balance-of",
		Short: "Call the BalanceOf view method on a DualFi contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			if accountRaw == "" {
				return fmt.Errorf("--account argument not specified")
			} else if !common.IsHexAddress(accountRaw) {
				return fmt.Errorf("--account argument is not a valid Ethereum address")
			}
			account = common.HexToAddress(accountRaw)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewDualFi(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := DualFiCallerSession{
				Contract: &contract.DualFiCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.BalanceOf(
				account,
			)
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %s\n", capture0.String())

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	cmd.Flags().StringVar(&accountRaw, "account", "", "account argument (common.Address)")

	return cmd
}
func CreateBasisCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var capture0 *big.Int

	cmd := &cobra.Command{
		Use:   "basis",
		Short: "Call the Basis view method on a DualFi contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewDualFi(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := DualFiCallerSession{
				Contract: &contract.DualFiCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.Basis()
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %s\n", capture0.String())

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	return cmd
}
func CreateCalculateDistributeAmountCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var erc20Value *big.Int
	var erc20ValueRaw string
	var nativeValue *big.Int
	var nativeValueRaw string

	var capture0 *big.Int

	cmd := &cobra.Command{
		Use:   "calculate-distribute-amount",
		Short: "Call the CalculateDistributeAmount view method on a DualFi contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			if erc20ValueRaw == "" {
				return fmt.Errorf("--erc-20-value argument not specified")
			}
			erc20Value = new(big.Int)
			erc20Value.SetString(erc20ValueRaw, 0)

			if nativeValueRaw == "" {
				return fmt.Errorf("--native-value argument not specified")
			}
			nativeValue = new(big.Int)
			nativeValue.SetString(nativeValueRaw, 0)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewDualFi(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := DualFiCallerSession{
				Contract: &contract.DualFiCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.CalculateDistributeAmount(
				erc20Value,
				nativeValue,
			)
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %s\n", capture0.String())

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	cmd.Flags().StringVar(&erc20ValueRaw, "erc-20-value", "", "erc-20-value argument")
	cmd.Flags().StringVar(&nativeValueRaw, "native-value", "", "native-value argument")

	return cmd
}
func CreateCalculateWithdrawAmountCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var amountIn *big.Int
	var amountInRaw string
	var wantNative bool
	var wantNativeRaw string

	var capture0 *big.Int

	cmd := &cobra.Command{
		Use:   "calculate-withdraw-amount",
		Short: "Call the CalculateWithdrawAmount view method on a DualFi contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			if amountInRaw == "" {
				return fmt.Errorf("--amount-in argument not specified")
			}
			amountIn = new(big.Int)
			amountIn.SetString(amountInRaw, 0)

			wantNativeRawLower := strings.ToLower(wantNativeRaw)
			switch wantNativeRawLower {
			case "true", "t", "y", "yes", "1":
				wantNative = true
			case "false", "f", "n", "no", "0":
				wantNative = false
			default:
				return fmt.Errorf("--want-native argument is not valid (value: %s)", wantNativeRaw)
			}

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewDualFi(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := DualFiCallerSession{
				Contract: &contract.DualFiCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.CalculateWithdrawAmount(
				amountIn,
				wantNative,
			)
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %s\n", capture0.String())

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	cmd.Flags().StringVar(&amountInRaw, "amount-in", "", "amount-in argument")
	cmd.Flags().StringVar(&wantNativeRaw, "want-native", "", "want-native argument (true, t, y, yes, 1 OR false, f, n, no, 0)")

	return cmd
}
func CreateDeadCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var capture0 common.Address

	cmd := &cobra.Command{
		Use:   "dead",
		Short: "Call the Dead view method on a DualFi contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewDualFi(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := DualFiCallerSession{
				Contract: &contract.DualFiCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.Dead()
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %s\n", capture0.Hex())

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	return cmd
}
func CreateDecimalsCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var capture0 uint8

	cmd := &cobra.Command{
		Use:   "decimals",
		Short: "Call the Decimals view method on a DualFi contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewDualFi(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := DualFiCallerSession{
				Contract: &contract.DualFiCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.Decimals()
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %d\n", capture0)

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	return cmd
}
func CreateInitialErc20RatioCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var capture0 *big.Int

	cmd := &cobra.Command{
		Use:   "initial-erc-20-ratio",
		Short: "Call the InitialERC20Ratio view method on a DualFi contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewDualFi(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := DualFiCallerSession{
				Contract: &contract.DualFiCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.InitialERC20Ratio()
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %s\n", capture0.String())

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	return cmd
}
func CreateInitialNativeRatioCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var capture0 *big.Int

	cmd := &cobra.Command{
		Use:   "initial-native-ratio",
		Short: "Call the InitialNativeRatio view method on a DualFi contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewDualFi(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := DualFiCallerSession{
				Contract: &contract.DualFiCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.InitialNativeRatio()
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %s\n", capture0.String())

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	return cmd
}
func CreateNameCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var capture0 string

	cmd := &cobra.Command{
		Use:   "name",
		Short: "Call the Name view method on a DualFi contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewDualFi(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := DualFiCallerSession{
				Contract: &contract.DualFiCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.Name()
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %s\n", capture0)

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	return cmd
}
func CreateSymbolCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var capture0 string

	cmd := &cobra.Command{
		Use:   "symbol",
		Short: "Call the Symbol view method on a DualFi contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewDualFi(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := DualFiCallerSession{
				Contract: &contract.DualFiCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.Symbol()
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %s\n", capture0)

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	return cmd
}
func CreateTokenCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var capture0 common.Address

	cmd := &cobra.Command{
		Use:   "token",
		Short: "Call the Token view method on a DualFi contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewDualFi(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := DualFiCallerSession{
				Contract: &contract.DualFiCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.Token()
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %s\n", capture0.Hex())

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	return cmd
}
func CreateTotalSupplyCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var capture0 *big.Int

	cmd := &cobra.Command{
		Use:   "total-supply",
		Short: "Call the TotalSupply view method on a DualFi contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewDualFi(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := DualFiCallerSession{
				Contract: &contract.DualFiCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.TotalSupply()
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %s\n", capture0.String())

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	return cmd
}
func CreateTrimValueCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var capture0 *big.Int

	cmd := &cobra.Command{
		Use:   "trim-value",
		Short: "Call the TrimValue view method on a DualFi contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewDualFi(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := DualFiCallerSession{
				Contract: &contract.DualFiCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.TrimValue()
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %s\n", capture0.String())

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	return cmd
}

func CreateApproveCommand() *cobra.Command {
	var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc, contractAddressRaw, safeFunction, safeNonceRaw string
	var gasLimit uint64
	var simulate bool
	var timeout uint
	var contractAddress common.Address
	var safeAddress, safeApi string
	var safeOperationType uint8
	var safeNonce *big.Int
	var calldata bool
	var staticCall bool

	var spender common.Address
	var spenderRaw string
	var value0 *big.Int
	var value0Raw string

	cmd := &cobra.Command{
		Use:   "approve",
		Short: "Execute the Approve method on a DualFi contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if !calldata {
				if contractAddressRaw == "" {
					return fmt.Errorf("--contract not specified")
				} else if !common.IsHexAddress(contractAddressRaw) {
					return fmt.Errorf("--contract is not a valid Ethereum address")
				}
				contractAddress = common.HexToAddress(contractAddressRaw)

				if keyfile == "" {
					return fmt.Errorf("--keystore not specified (this should be a path to an Ethereum account keystore file)")
				}

				if rpc == "" {
					return fmt.Errorf("--rpc not specified (this should be a URL to an Ethereum JSONRPC API)")
				}
			}

			if safeAddress != "" {
				if !common.IsHexAddress(safeAddress) {
					return fmt.Errorf("--safe is not a valid Ethereum address")
				}
				if safeApi == "" {
					client, clientErr := NewClient(rpc)
					if clientErr != nil {
						return clientErr
					}
					chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
					defer cancelChainIDCtx()
					chainID, chainIDErr := client.ChainID(chainIDCtx)
					if chainIDErr != nil {
						return chainIDErr
					}
					safeApi = fmt.Sprintf("https://safe-client.safe.global/v1/chains/%s/transactions/%s/propose", chainID.String(), safeAddress)
					fmt.Println("--safe-api not specified, using default (", safeApi, ")")
				}

				if SafeOperationType(safeOperationType).String() == "Unknown" {
					return fmt.Errorf("--safe-operation must be 0 (Call) or 1 (DelegateCall)")
				}

				if safeNonceRaw == "" {
					fmt.Println("--safe-nonce not specified, fetching nonce from Safe contract")
				} else {
					safeNonce = new(big.Int)
					_, ok := safeNonce.SetString(safeNonceRaw, 0)
					if !ok {
						return fmt.Errorf("--safe-nonce is not a valid big integer")
					}
				}
			}

			if spenderRaw == "" {
				return fmt.Errorf("--spender argument not specified")
			} else if !common.IsHexAddress(spenderRaw) {
				return fmt.Errorf("--spender argument is not a valid Ethereum address")
			}
			spender = common.HexToAddress(spenderRaw)

			if value0Raw == "" {
				return fmt.Errorf("--value-0 argument not specified")
			}
			value0 = new(big.Int)
			value0.SetString(value0Raw, 0)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			abi, err := DualFiMetaData.GetAbi()
			if err != nil {
				return fmt.Errorf("failed to get ABI: %v", err)
			}

			// Generate transaction data (override method name if safe function is specified)
			methodName := "approve"
			if safeFunction != "" {
				methodName = safeFunction
			}

			txCalldata, err := abi.Pack(
				methodName,
				spender,
				value0,
			)

			if err != nil {
				return err
			}

			if staticCall {
				client, clientErr := NewClient(rpc)
				if clientErr != nil {
					return clientErr
				}

				// Create the call message
				msg := ethereum.CallMsg{
					To:   &contractAddress,
					Data: txCalldata,
				}

				// Create context with timeout
				ctx, cancel := NewChainContext(timeout)
				defer cancel()

				// Perform static call
				output, err := client.CallContract(ctx, msg, nil)
				if err != nil {
					return fmt.Errorf("static call failed: %v", err)
				}

				// Unpack the result
				result, err := abi.Unpack(methodName, output)
				if err != nil {
					return fmt.Errorf("failed to unpack result: %v", err)
				}

				if len(result) > 0 {
					// Get method outputs from ABI to access parameter names
					method, exists := abi.Methods[methodName]
					if !exists {
						return fmt.Errorf("method %s not found in ABI", methodName)
					}

					// Print each return value
					for i, val := range result {
						// Get parameter name if available
						paramName := fmt.Sprintf("output%d", i)
						if i < len(method.Outputs) {
							if method.Outputs[i].Name != "" {
								paramName = method.Outputs[i].Name
							}
						}
						switch v := val.(type) {
						case bool:
							cmd.Printf("%s: %t\n", paramName, v)
						case string:
							cmd.Printf("%s: %s\n", paramName, v)
						case *big.Int:
							cmd.Printf("%s: %s\n", paramName, v.String())
						case common.Address:
							cmd.Printf("%s: %s\n", paramName, v.Hex())
						default:
							rv := reflect.ValueOf(v)
							if rv.Kind() == reflect.Struct {
								PrintStruct(cmd, paramName, rv, 0)
							} else {
								cmd.Printf("%s: %v\n", paramName, v)
							}
						}
					}
				} else {
					return fmt.Errorf("no result returned from static call")
				}

				return nil
			}

			if calldata {
				txCalldataHex := hex.EncodeToString(txCalldata)
				cmd.Println(txCalldataHex)
				return nil
			}

			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			key, keyErr := KeyFromFile(keyfile, password)
			if keyErr != nil {
				return keyErr
			}

			chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
			defer cancelChainIDCtx()
			chainID, chainIDErr := client.ChainID(chainIDCtx)
			if chainIDErr != nil {
				return chainIDErr
			}

			transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
			if transactionOptsErr != nil {
				return transactionOptsErr
			}

			SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

			contract, contractErr := NewDualFi(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			session := DualFiTransactorSession{
				Contract:     &contract.DualFiTransactor,
				TransactOpts: *transactionOpts,
			}

			if safeAddress != "" {
				// Create Safe proposal for transaction
				value := transactionOpts.Value
				if value == nil {
					value = big.NewInt(0)
				}

				err = CreateSafeProposal(client, key, common.HexToAddress(safeAddress), contractAddress, txCalldata, value, safeApi, SafeOperationType(safeOperationType), safeNonce)
				if err != nil {
					return fmt.Errorf("failed to create Safe proposal: %v", err)
				}

				return nil
			}

			transaction, err := session.Approve(

				spender,
				value0,
			)
			if err != nil {
				return err
			}

			cmd.Printf("Transaction hash: %s\n", transaction.Hash().Hex())
			if transactionOpts.NoSend {
				estimationMessage := ethereum.CallMsg{
					From: transactionOpts.From,
					To:   &contractAddress,
					Data: transaction.Data(),
				}

				gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
				defer cancelGasEstimationCtx()

				gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
				if gasEstimateErr != nil {
					return gasEstimateErr
				}

				transactionBinary, transactionBinaryErr := transaction.MarshalBinary()
				if transactionBinaryErr != nil {
					return transactionBinaryErr
				}
				transactionBinaryHex := hex.EncodeToString(transactionBinary)

				cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
			} else {
				cmd.Println("Transaction submitted")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
	cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
	cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
	cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
	cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
	cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
	cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&safeAddress, "safe", "", "Address of the Safe contract")
	cmd.Flags().StringVar(&safeApi, "safe-api", "", "Safe API for the Safe Transaction Service (optional)")
	cmd.Flags().Uint8Var(&safeOperationType, "safe-operation", 0, "Safe operation type: 0 (Call) or 1 (DelegateCall)")
	cmd.Flags().StringVar(&safeFunction, "safe-function", "", "Safe function overrider to use for the transaction (optional)")
	cmd.Flags().StringVar(&safeNonceRaw, "safe-nonce", "", "Safe nonce overrider for the transaction (optional)")
	cmd.Flags().BoolVar(&calldata, "calldata", false, "Set this flag if want to return the calldata instead of sending the transaction")
	cmd.Flags().BoolVar(&staticCall, "static-call", false, "Set this flag if want to call the method without sending a transaction")

	cmd.Flags().StringVar(&spenderRaw, "spender", "", "spender argument (common.Address)")
	cmd.Flags().StringVar(&value0Raw, "value-0", "", "value-0 argument")

	return cmd
}
func CreateDepositCommand() *cobra.Command {
	var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc, contractAddressRaw, safeFunction, safeNonceRaw string
	var gasLimit uint64
	var simulate bool
	var timeout uint
	var contractAddress common.Address
	var safeAddress, safeApi string
	var safeOperationType uint8
	var safeNonce *big.Int
	var calldata bool
	var staticCall bool

	var value0 *big.Int
	var value0Raw string

	cmd := &cobra.Command{
		Use:   "deposit",
		Short: "Execute the Deposit method on a DualFi contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if !calldata {
				if contractAddressRaw == "" {
					return fmt.Errorf("--contract not specified")
				} else if !common.IsHexAddress(contractAddressRaw) {
					return fmt.Errorf("--contract is not a valid Ethereum address")
				}
				contractAddress = common.HexToAddress(contractAddressRaw)

				if keyfile == "" {
					return fmt.Errorf("--keystore not specified (this should be a path to an Ethereum account keystore file)")
				}

				if rpc == "" {
					return fmt.Errorf("--rpc not specified (this should be a URL to an Ethereum JSONRPC API)")
				}
			}

			if safeAddress != "" {
				if !common.IsHexAddress(safeAddress) {
					return fmt.Errorf("--safe is not a valid Ethereum address")
				}
				if safeApi == "" {
					client, clientErr := NewClient(rpc)
					if clientErr != nil {
						return clientErr
					}
					chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
					defer cancelChainIDCtx()
					chainID, chainIDErr := client.ChainID(chainIDCtx)
					if chainIDErr != nil {
						return chainIDErr
					}
					safeApi = fmt.Sprintf("https://safe-client.safe.global/v1/chains/%s/transactions/%s/propose", chainID.String(), safeAddress)
					fmt.Println("--safe-api not specified, using default (", safeApi, ")")
				}

				if SafeOperationType(safeOperationType).String() == "Unknown" {
					return fmt.Errorf("--safe-operation must be 0 (Call) or 1 (DelegateCall)")
				}

				if safeNonceRaw == "" {
					fmt.Println("--safe-nonce not specified, fetching nonce from Safe contract")
				} else {
					safeNonce = new(big.Int)
					_, ok := safeNonce.SetString(safeNonceRaw, 0)
					if !ok {
						return fmt.Errorf("--safe-nonce is not a valid big integer")
					}
				}
			}

			if value0Raw == "" {
				return fmt.Errorf("--value-0 argument not specified")
			}
			value0 = new(big.Int)
			value0.SetString(value0Raw, 0)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			abi, err := DualFiMetaData.GetAbi()
			if err != nil {
				return fmt.Errorf("failed to get ABI: %v", err)
			}

			// Generate transaction data (override method name if safe function is specified)
			methodName := "deposit"
			if safeFunction != "" {
				methodName = safeFunction
			}

			txCalldata, err := abi.Pack(
				methodName,
				value0,
			)

			if err != nil {
				return err
			}

			if staticCall {
				client, clientErr := NewClient(rpc)
				if clientErr != nil {
					return clientErr
				}

				// Create the call message
				msg := ethereum.CallMsg{
					To:   &contractAddress,
					Data: txCalldata,
				}

				// Create context with timeout
				ctx, cancel := NewChainContext(timeout)
				defer cancel()

				// Perform static call
				output, err := client.CallContract(ctx, msg, nil)
				if err != nil {
					return fmt.Errorf("static call failed: %v", err)
				}

				// Unpack the result
				result, err := abi.Unpack(methodName, output)
				if err != nil {
					return fmt.Errorf("failed to unpack result: %v", err)
				}

				if len(result) > 0 {
					// Get method outputs from ABI to access parameter names
					method, exists := abi.Methods[methodName]
					if !exists {
						return fmt.Errorf("method %s not found in ABI", methodName)
					}

					// Print each return value
					for i, val := range result {
						// Get parameter name if available
						paramName := fmt.Sprintf("output%d", i)
						if i < len(method.Outputs) {
							if method.Outputs[i].Name != "" {
								paramName = method.Outputs[i].Name
							}
						}
						switch v := val.(type) {
						case bool:
							cmd.Printf("%s: %t\n", paramName, v)
						case string:
							cmd.Printf("%s: %s\n", paramName, v)
						case *big.Int:
							cmd.Printf("%s: %s\n", paramName, v.String())
						case common.Address:
							cmd.Printf("%s: %s\n", paramName, v.Hex())
						default:
							rv := reflect.ValueOf(v)
							if rv.Kind() == reflect.Struct {
								PrintStruct(cmd, paramName, rv, 0)
							} else {
								cmd.Printf("%s: %v\n", paramName, v)
							}
						}
					}
				} else {
					return fmt.Errorf("no result returned from static call")
				}

				return nil
			}

			if calldata {
				txCalldataHex := hex.EncodeToString(txCalldata)
				cmd.Println(txCalldataHex)
				return nil
			}

			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			key, keyErr := KeyFromFile(keyfile, password)
			if keyErr != nil {
				return keyErr
			}

			chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
			defer cancelChainIDCtx()
			chainID, chainIDErr := client.ChainID(chainIDCtx)
			if chainIDErr != nil {
				return chainIDErr
			}

			transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
			if transactionOptsErr != nil {
				return transactionOptsErr
			}

			SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

			contract, contractErr := NewDualFi(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			session := DualFiTransactorSession{
				Contract:     &contract.DualFiTransactor,
				TransactOpts: *transactionOpts,
			}

			if safeAddress != "" {
				// Create Safe proposal for transaction
				value := transactionOpts.Value
				if value == nil {
					value = big.NewInt(0)
				}

				err = CreateSafeProposal(client, key, common.HexToAddress(safeAddress), contractAddress, txCalldata, value, safeApi, SafeOperationType(safeOperationType), safeNonce)
				if err != nil {
					return fmt.Errorf("failed to create Safe proposal: %v", err)
				}

				return nil
			}

			transaction, err := session.Deposit(

				value0,
			)
			if err != nil {
				return err
			}

			cmd.Printf("Transaction hash: %s\n", transaction.Hash().Hex())
			if transactionOpts.NoSend {
				estimationMessage := ethereum.CallMsg{
					From: transactionOpts.From,
					To:   &contractAddress,
					Data: transaction.Data(),
				}

				gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
				defer cancelGasEstimationCtx()

				gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
				if gasEstimateErr != nil {
					return gasEstimateErr
				}

				transactionBinary, transactionBinaryErr := transaction.MarshalBinary()
				if transactionBinaryErr != nil {
					return transactionBinaryErr
				}
				transactionBinaryHex := hex.EncodeToString(transactionBinary)

				cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
			} else {
				cmd.Println("Transaction submitted")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
	cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
	cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
	cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
	cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
	cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
	cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&safeAddress, "safe", "", "Address of the Safe contract")
	cmd.Flags().StringVar(&safeApi, "safe-api", "", "Safe API for the Safe Transaction Service (optional)")
	cmd.Flags().Uint8Var(&safeOperationType, "safe-operation", 0, "Safe operation type: 0 (Call) or 1 (DelegateCall)")
	cmd.Flags().StringVar(&safeFunction, "safe-function", "", "Safe function overrider to use for the transaction (optional)")
	cmd.Flags().StringVar(&safeNonceRaw, "safe-nonce", "", "Safe nonce overrider for the transaction (optional)")
	cmd.Flags().BoolVar(&calldata, "calldata", false, "Set this flag if want to return the calldata instead of sending the transaction")
	cmd.Flags().BoolVar(&staticCall, "static-call", false, "Set this flag if want to call the method without sending a transaction")

	cmd.Flags().StringVar(&value0Raw, "value-0", "", "value-0 argument")

	return cmd
}
func CreateSwapNativeForTokenCommand() *cobra.Command {
	var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc, contractAddressRaw, safeFunction, safeNonceRaw string
	var gasLimit uint64
	var simulate bool
	var timeout uint
	var contractAddress common.Address
	var safeAddress, safeApi string
	var safeOperationType uint8
	var safeNonce *big.Int
	var calldata bool
	var staticCall bool

	cmd := &cobra.Command{
		Use:   "swap-native-for-token",
		Short: "Execute the SwapNativeForToken method on a DualFi contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if !calldata {
				if contractAddressRaw == "" {
					return fmt.Errorf("--contract not specified")
				} else if !common.IsHexAddress(contractAddressRaw) {
					return fmt.Errorf("--contract is not a valid Ethereum address")
				}
				contractAddress = common.HexToAddress(contractAddressRaw)

				if keyfile == "" {
					return fmt.Errorf("--keystore not specified (this should be a path to an Ethereum account keystore file)")
				}

				if rpc == "" {
					return fmt.Errorf("--rpc not specified (this should be a URL to an Ethereum JSONRPC API)")
				}
			}

			if safeAddress != "" {
				if !common.IsHexAddress(safeAddress) {
					return fmt.Errorf("--safe is not a valid Ethereum address")
				}
				if safeApi == "" {
					client, clientErr := NewClient(rpc)
					if clientErr != nil {
						return clientErr
					}
					chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
					defer cancelChainIDCtx()
					chainID, chainIDErr := client.ChainID(chainIDCtx)
					if chainIDErr != nil {
						return chainIDErr
					}
					safeApi = fmt.Sprintf("https://safe-client.safe.global/v1/chains/%s/transactions/%s/propose", chainID.String(), safeAddress)
					fmt.Println("--safe-api not specified, using default (", safeApi, ")")
				}

				if SafeOperationType(safeOperationType).String() == "Unknown" {
					return fmt.Errorf("--safe-operation must be 0 (Call) or 1 (DelegateCall)")
				}

				if safeNonceRaw == "" {
					fmt.Println("--safe-nonce not specified, fetching nonce from Safe contract")
				} else {
					safeNonce = new(big.Int)
					_, ok := safeNonce.SetString(safeNonceRaw, 0)
					if !ok {
						return fmt.Errorf("--safe-nonce is not a valid big integer")
					}
				}
			}

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			abi, err := DualFiMetaData.GetAbi()
			if err != nil {
				return fmt.Errorf("failed to get ABI: %v", err)
			}

			// Generate transaction data (override method name if safe function is specified)
			methodName := "swapNativeForToken"
			if safeFunction != "" {
				methodName = safeFunction
			}

			txCalldata, err := abi.Pack(
				methodName,
			)

			if err != nil {
				return err
			}

			if staticCall {
				client, clientErr := NewClient(rpc)
				if clientErr != nil {
					return clientErr
				}

				// Create the call message
				msg := ethereum.CallMsg{
					To:   &contractAddress,
					Data: txCalldata,
				}

				// Create context with timeout
				ctx, cancel := NewChainContext(timeout)
				defer cancel()

				// Perform static call
				output, err := client.CallContract(ctx, msg, nil)
				if err != nil {
					return fmt.Errorf("static call failed: %v", err)
				}

				// Unpack the result
				result, err := abi.Unpack(methodName, output)
				if err != nil {
					return fmt.Errorf("failed to unpack result: %v", err)
				}

				if len(result) > 0 {
					// Get method outputs from ABI to access parameter names
					method, exists := abi.Methods[methodName]
					if !exists {
						return fmt.Errorf("method %s not found in ABI", methodName)
					}

					// Print each return value
					for i, val := range result {
						// Get parameter name if available
						paramName := fmt.Sprintf("output%d", i)
						if i < len(method.Outputs) {
							if method.Outputs[i].Name != "" {
								paramName = method.Outputs[i].Name
							}
						}
						switch v := val.(type) {
						case bool:
							cmd.Printf("%s: %t\n", paramName, v)
						case string:
							cmd.Printf("%s: %s\n", paramName, v)
						case *big.Int:
							cmd.Printf("%s: %s\n", paramName, v.String())
						case common.Address:
							cmd.Printf("%s: %s\n", paramName, v.Hex())
						default:
							rv := reflect.ValueOf(v)
							if rv.Kind() == reflect.Struct {
								PrintStruct(cmd, paramName, rv, 0)
							} else {
								cmd.Printf("%s: %v\n", paramName, v)
							}
						}
					}
				} else {
					return fmt.Errorf("no result returned from static call")
				}

				return nil
			}

			if calldata {
				txCalldataHex := hex.EncodeToString(txCalldata)
				cmd.Println(txCalldataHex)
				return nil
			}

			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			key, keyErr := KeyFromFile(keyfile, password)
			if keyErr != nil {
				return keyErr
			}

			chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
			defer cancelChainIDCtx()
			chainID, chainIDErr := client.ChainID(chainIDCtx)
			if chainIDErr != nil {
				return chainIDErr
			}

			transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
			if transactionOptsErr != nil {
				return transactionOptsErr
			}

			SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

			contract, contractErr := NewDualFi(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			session := DualFiTransactorSession{
				Contract:     &contract.DualFiTransactor,
				TransactOpts: *transactionOpts,
			}

			if safeAddress != "" {
				// Create Safe proposal for transaction
				value := transactionOpts.Value
				if value == nil {
					value = big.NewInt(0)
				}

				err = CreateSafeProposal(client, key, common.HexToAddress(safeAddress), contractAddress, txCalldata, value, safeApi, SafeOperationType(safeOperationType), safeNonce)
				if err != nil {
					return fmt.Errorf("failed to create Safe proposal: %v", err)
				}

				return nil
			}

			transaction, err := session.SwapNativeForToken()
			if err != nil {
				return err
			}

			cmd.Printf("Transaction hash: %s\n", transaction.Hash().Hex())
			if transactionOpts.NoSend {
				estimationMessage := ethereum.CallMsg{
					From: transactionOpts.From,
					To:   &contractAddress,
					Data: transaction.Data(),
				}

				gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
				defer cancelGasEstimationCtx()

				gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
				if gasEstimateErr != nil {
					return gasEstimateErr
				}

				transactionBinary, transactionBinaryErr := transaction.MarshalBinary()
				if transactionBinaryErr != nil {
					return transactionBinaryErr
				}
				transactionBinaryHex := hex.EncodeToString(transactionBinary)

				cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
			} else {
				cmd.Println("Transaction submitted")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
	cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
	cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
	cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
	cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
	cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
	cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&safeAddress, "safe", "", "Address of the Safe contract")
	cmd.Flags().StringVar(&safeApi, "safe-api", "", "Safe API for the Safe Transaction Service (optional)")
	cmd.Flags().Uint8Var(&safeOperationType, "safe-operation", 0, "Safe operation type: 0 (Call) or 1 (DelegateCall)")
	cmd.Flags().StringVar(&safeFunction, "safe-function", "", "Safe function overrider to use for the transaction (optional)")
	cmd.Flags().StringVar(&safeNonceRaw, "safe-nonce", "", "Safe nonce overrider for the transaction (optional)")
	cmd.Flags().BoolVar(&calldata, "calldata", false, "Set this flag if want to return the calldata instead of sending the transaction")
	cmd.Flags().BoolVar(&staticCall, "static-call", false, "Set this flag if want to call the method without sending a transaction")

	return cmd
}
func CreateSwapTokenForNativeCommand() *cobra.Command {
	var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc, contractAddressRaw, safeFunction, safeNonceRaw string
	var gasLimit uint64
	var simulate bool
	var timeout uint
	var contractAddress common.Address
	var safeAddress, safeApi string
	var safeOperationType uint8
	var safeNonce *big.Int
	var calldata bool
	var staticCall bool

	var amountIn *big.Int
	var amountInRaw string

	cmd := &cobra.Command{
		Use:   "swap-token-for-native",
		Short: "Execute the SwapTokenForNative method on a DualFi contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if !calldata {
				if contractAddressRaw == "" {
					return fmt.Errorf("--contract not specified")
				} else if !common.IsHexAddress(contractAddressRaw) {
					return fmt.Errorf("--contract is not a valid Ethereum address")
				}
				contractAddress = common.HexToAddress(contractAddressRaw)

				if keyfile == "" {
					return fmt.Errorf("--keystore not specified (this should be a path to an Ethereum account keystore file)")
				}

				if rpc == "" {
					return fmt.Errorf("--rpc not specified (this should be a URL to an Ethereum JSONRPC API)")
				}
			}

			if safeAddress != "" {
				if !common.IsHexAddress(safeAddress) {
					return fmt.Errorf("--safe is not a valid Ethereum address")
				}
				if safeApi == "" {
					client, clientErr := NewClient(rpc)
					if clientErr != nil {
						return clientErr
					}
					chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
					defer cancelChainIDCtx()
					chainID, chainIDErr := client.ChainID(chainIDCtx)
					if chainIDErr != nil {
						return chainIDErr
					}
					safeApi = fmt.Sprintf("https://safe-client.safe.global/v1/chains/%s/transactions/%s/propose", chainID.String(), safeAddress)
					fmt.Println("--safe-api not specified, using default (", safeApi, ")")
				}

				if SafeOperationType(safeOperationType).String() == "Unknown" {
					return fmt.Errorf("--safe-operation must be 0 (Call) or 1 (DelegateCall)")
				}

				if safeNonceRaw == "" {
					fmt.Println("--safe-nonce not specified, fetching nonce from Safe contract")
				} else {
					safeNonce = new(big.Int)
					_, ok := safeNonce.SetString(safeNonceRaw, 0)
					if !ok {
						return fmt.Errorf("--safe-nonce is not a valid big integer")
					}
				}
			}

			if amountInRaw == "" {
				return fmt.Errorf("--amount-in argument not specified")
			}
			amountIn = new(big.Int)
			amountIn.SetString(amountInRaw, 0)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			abi, err := DualFiMetaData.GetAbi()
			if err != nil {
				return fmt.Errorf("failed to get ABI: %v", err)
			}

			// Generate transaction data (override method name if safe function is specified)
			methodName := "swapTokenForNative"
			if safeFunction != "" {
				methodName = safeFunction
			}

			txCalldata, err := abi.Pack(
				methodName,
				amountIn,
			)

			if err != nil {
				return err
			}

			if staticCall {
				client, clientErr := NewClient(rpc)
				if clientErr != nil {
					return clientErr
				}

				// Create the call message
				msg := ethereum.CallMsg{
					To:   &contractAddress,
					Data: txCalldata,
				}

				// Create context with timeout
				ctx, cancel := NewChainContext(timeout)
				defer cancel()

				// Perform static call
				output, err := client.CallContract(ctx, msg, nil)
				if err != nil {
					return fmt.Errorf("static call failed: %v", err)
				}

				// Unpack the result
				result, err := abi.Unpack(methodName, output)
				if err != nil {
					return fmt.Errorf("failed to unpack result: %v", err)
				}

				if len(result) > 0 {
					// Get method outputs from ABI to access parameter names
					method, exists := abi.Methods[methodName]
					if !exists {
						return fmt.Errorf("method %s not found in ABI", methodName)
					}

					// Print each return value
					for i, val := range result {
						// Get parameter name if available
						paramName := fmt.Sprintf("output%d", i)
						if i < len(method.Outputs) {
							if method.Outputs[i].Name != "" {
								paramName = method.Outputs[i].Name
							}
						}
						switch v := val.(type) {
						case bool:
							cmd.Printf("%s: %t\n", paramName, v)
						case string:
							cmd.Printf("%s: %s\n", paramName, v)
						case *big.Int:
							cmd.Printf("%s: %s\n", paramName, v.String())
						case common.Address:
							cmd.Printf("%s: %s\n", paramName, v.Hex())
						default:
							rv := reflect.ValueOf(v)
							if rv.Kind() == reflect.Struct {
								PrintStruct(cmd, paramName, rv, 0)
							} else {
								cmd.Printf("%s: %v\n", paramName, v)
							}
						}
					}
				} else {
					return fmt.Errorf("no result returned from static call")
				}

				return nil
			}

			if calldata {
				txCalldataHex := hex.EncodeToString(txCalldata)
				cmd.Println(txCalldataHex)
				return nil
			}

			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			key, keyErr := KeyFromFile(keyfile, password)
			if keyErr != nil {
				return keyErr
			}

			chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
			defer cancelChainIDCtx()
			chainID, chainIDErr := client.ChainID(chainIDCtx)
			if chainIDErr != nil {
				return chainIDErr
			}

			transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
			if transactionOptsErr != nil {
				return transactionOptsErr
			}

			SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

			contract, contractErr := NewDualFi(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			session := DualFiTransactorSession{
				Contract:     &contract.DualFiTransactor,
				TransactOpts: *transactionOpts,
			}

			if safeAddress != "" {
				// Create Safe proposal for transaction
				value := transactionOpts.Value
				if value == nil {
					value = big.NewInt(0)
				}

				err = CreateSafeProposal(client, key, common.HexToAddress(safeAddress), contractAddress, txCalldata, value, safeApi, SafeOperationType(safeOperationType), safeNonce)
				if err != nil {
					return fmt.Errorf("failed to create Safe proposal: %v", err)
				}

				return nil
			}

			transaction, err := session.SwapTokenForNative(

				amountIn,
			)
			if err != nil {
				return err
			}

			cmd.Printf("Transaction hash: %s\n", transaction.Hash().Hex())
			if transactionOpts.NoSend {
				estimationMessage := ethereum.CallMsg{
					From: transactionOpts.From,
					To:   &contractAddress,
					Data: transaction.Data(),
				}

				gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
				defer cancelGasEstimationCtx()

				gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
				if gasEstimateErr != nil {
					return gasEstimateErr
				}

				transactionBinary, transactionBinaryErr := transaction.MarshalBinary()
				if transactionBinaryErr != nil {
					return transactionBinaryErr
				}
				transactionBinaryHex := hex.EncodeToString(transactionBinary)

				cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
			} else {
				cmd.Println("Transaction submitted")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
	cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
	cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
	cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
	cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
	cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
	cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&safeAddress, "safe", "", "Address of the Safe contract")
	cmd.Flags().StringVar(&safeApi, "safe-api", "", "Safe API for the Safe Transaction Service (optional)")
	cmd.Flags().Uint8Var(&safeOperationType, "safe-operation", 0, "Safe operation type: 0 (Call) or 1 (DelegateCall)")
	cmd.Flags().StringVar(&safeFunction, "safe-function", "", "Safe function overrider to use for the transaction (optional)")
	cmd.Flags().StringVar(&safeNonceRaw, "safe-nonce", "", "Safe nonce overrider for the transaction (optional)")
	cmd.Flags().BoolVar(&calldata, "calldata", false, "Set this flag if want to return the calldata instead of sending the transaction")
	cmd.Flags().BoolVar(&staticCall, "static-call", false, "Set this flag if want to call the method without sending a transaction")

	cmd.Flags().StringVar(&amountInRaw, "amount-in", "", "amount-in argument")

	return cmd
}
func CreateTransferCommand() *cobra.Command {
	var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc, contractAddressRaw, safeFunction, safeNonceRaw string
	var gasLimit uint64
	var simulate bool
	var timeout uint
	var contractAddress common.Address
	var safeAddress, safeApi string
	var safeOperationType uint8
	var safeNonce *big.Int
	var calldata bool
	var staticCall bool

	var to0 common.Address
	var to0Raw string
	var value0 *big.Int
	var value0Raw string

	cmd := &cobra.Command{
		Use:   "transfer",
		Short: "Execute the Transfer method on a DualFi contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if !calldata {
				if contractAddressRaw == "" {
					return fmt.Errorf("--contract not specified")
				} else if !common.IsHexAddress(contractAddressRaw) {
					return fmt.Errorf("--contract is not a valid Ethereum address")
				}
				contractAddress = common.HexToAddress(contractAddressRaw)

				if keyfile == "" {
					return fmt.Errorf("--keystore not specified (this should be a path to an Ethereum account keystore file)")
				}

				if rpc == "" {
					return fmt.Errorf("--rpc not specified (this should be a URL to an Ethereum JSONRPC API)")
				}
			}

			if safeAddress != "" {
				if !common.IsHexAddress(safeAddress) {
					return fmt.Errorf("--safe is not a valid Ethereum address")
				}
				if safeApi == "" {
					client, clientErr := NewClient(rpc)
					if clientErr != nil {
						return clientErr
					}
					chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
					defer cancelChainIDCtx()
					chainID, chainIDErr := client.ChainID(chainIDCtx)
					if chainIDErr != nil {
						return chainIDErr
					}
					safeApi = fmt.Sprintf("https://safe-client.safe.global/v1/chains/%s/transactions/%s/propose", chainID.String(), safeAddress)
					fmt.Println("--safe-api not specified, using default (", safeApi, ")")
				}

				if SafeOperationType(safeOperationType).String() == "Unknown" {
					return fmt.Errorf("--safe-operation must be 0 (Call) or 1 (DelegateCall)")
				}

				if safeNonceRaw == "" {
					fmt.Println("--safe-nonce not specified, fetching nonce from Safe contract")
				} else {
					safeNonce = new(big.Int)
					_, ok := safeNonce.SetString(safeNonceRaw, 0)
					if !ok {
						return fmt.Errorf("--safe-nonce is not a valid big integer")
					}
				}
			}

			if to0Raw == "" {
				return fmt.Errorf("--to-0 argument not specified")
			} else if !common.IsHexAddress(to0Raw) {
				return fmt.Errorf("--to-0 argument is not a valid Ethereum address")
			}
			to0 = common.HexToAddress(to0Raw)

			if value0Raw == "" {
				return fmt.Errorf("--value-0 argument not specified")
			}
			value0 = new(big.Int)
			value0.SetString(value0Raw, 0)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			abi, err := DualFiMetaData.GetAbi()
			if err != nil {
				return fmt.Errorf("failed to get ABI: %v", err)
			}

			// Generate transaction data (override method name if safe function is specified)
			methodName := "transfer"
			if safeFunction != "" {
				methodName = safeFunction
			}

			txCalldata, err := abi.Pack(
				methodName,
				to0,
				value0,
			)

			if err != nil {
				return err
			}

			if staticCall {
				client, clientErr := NewClient(rpc)
				if clientErr != nil {
					return clientErr
				}

				// Create the call message
				msg := ethereum.CallMsg{
					To:   &contractAddress,
					Data: txCalldata,
				}

				// Create context with timeout
				ctx, cancel := NewChainContext(timeout)
				defer cancel()

				// Perform static call
				output, err := client.CallContract(ctx, msg, nil)
				if err != nil {
					return fmt.Errorf("static call failed: %v", err)
				}

				// Unpack the result
				result, err := abi.Unpack(methodName, output)
				if err != nil {
					return fmt.Errorf("failed to unpack result: %v", err)
				}

				if len(result) > 0 {
					// Get method outputs from ABI to access parameter names
					method, exists := abi.Methods[methodName]
					if !exists {
						return fmt.Errorf("method %s not found in ABI", methodName)
					}

					// Print each return value
					for i, val := range result {
						// Get parameter name if available
						paramName := fmt.Sprintf("output%d", i)
						if i < len(method.Outputs) {
							if method.Outputs[i].Name != "" {
								paramName = method.Outputs[i].Name
							}
						}
						switch v := val.(type) {
						case bool:
							cmd.Printf("%s: %t\n", paramName, v)
						case string:
							cmd.Printf("%s: %s\n", paramName, v)
						case *big.Int:
							cmd.Printf("%s: %s\n", paramName, v.String())
						case common.Address:
							cmd.Printf("%s: %s\n", paramName, v.Hex())
						default:
							rv := reflect.ValueOf(v)
							if rv.Kind() == reflect.Struct {
								PrintStruct(cmd, paramName, rv, 0)
							} else {
								cmd.Printf("%s: %v\n", paramName, v)
							}
						}
					}
				} else {
					return fmt.Errorf("no result returned from static call")
				}

				return nil
			}

			if calldata {
				txCalldataHex := hex.EncodeToString(txCalldata)
				cmd.Println(txCalldataHex)
				return nil
			}

			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			key, keyErr := KeyFromFile(keyfile, password)
			if keyErr != nil {
				return keyErr
			}

			chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
			defer cancelChainIDCtx()
			chainID, chainIDErr := client.ChainID(chainIDCtx)
			if chainIDErr != nil {
				return chainIDErr
			}

			transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
			if transactionOptsErr != nil {
				return transactionOptsErr
			}

			SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

			contract, contractErr := NewDualFi(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			session := DualFiTransactorSession{
				Contract:     &contract.DualFiTransactor,
				TransactOpts: *transactionOpts,
			}

			if safeAddress != "" {
				// Create Safe proposal for transaction
				value := transactionOpts.Value
				if value == nil {
					value = big.NewInt(0)
				}

				err = CreateSafeProposal(client, key, common.HexToAddress(safeAddress), contractAddress, txCalldata, value, safeApi, SafeOperationType(safeOperationType), safeNonce)
				if err != nil {
					return fmt.Errorf("failed to create Safe proposal: %v", err)
				}

				return nil
			}

			transaction, err := session.Transfer(

				to0,
				value0,
			)
			if err != nil {
				return err
			}

			cmd.Printf("Transaction hash: %s\n", transaction.Hash().Hex())
			if transactionOpts.NoSend {
				estimationMessage := ethereum.CallMsg{
					From: transactionOpts.From,
					To:   &contractAddress,
					Data: transaction.Data(),
				}

				gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
				defer cancelGasEstimationCtx()

				gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
				if gasEstimateErr != nil {
					return gasEstimateErr
				}

				transactionBinary, transactionBinaryErr := transaction.MarshalBinary()
				if transactionBinaryErr != nil {
					return transactionBinaryErr
				}
				transactionBinaryHex := hex.EncodeToString(transactionBinary)

				cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
			} else {
				cmd.Println("Transaction submitted")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
	cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
	cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
	cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
	cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
	cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
	cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&safeAddress, "safe", "", "Address of the Safe contract")
	cmd.Flags().StringVar(&safeApi, "safe-api", "", "Safe API for the Safe Transaction Service (optional)")
	cmd.Flags().Uint8Var(&safeOperationType, "safe-operation", 0, "Safe operation type: 0 (Call) or 1 (DelegateCall)")
	cmd.Flags().StringVar(&safeFunction, "safe-function", "", "Safe function overrider to use for the transaction (optional)")
	cmd.Flags().StringVar(&safeNonceRaw, "safe-nonce", "", "Safe nonce overrider for the transaction (optional)")
	cmd.Flags().BoolVar(&calldata, "calldata", false, "Set this flag if want to return the calldata instead of sending the transaction")
	cmd.Flags().BoolVar(&staticCall, "static-call", false, "Set this flag if want to call the method without sending a transaction")

	cmd.Flags().StringVar(&to0Raw, "to-0", "", "to-0 argument (common.Address)")
	cmd.Flags().StringVar(&value0Raw, "value-0", "", "value-0 argument")

	return cmd
}
func CreateTransferFromCommand() *cobra.Command {
	var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc, contractAddressRaw, safeFunction, safeNonceRaw string
	var gasLimit uint64
	var simulate bool
	var timeout uint
	var contractAddress common.Address
	var safeAddress, safeApi string
	var safeOperationType uint8
	var safeNonce *big.Int
	var calldata bool
	var staticCall bool

	var from0 common.Address
	var from0Raw string
	var to0 common.Address
	var to0Raw string
	var value0 *big.Int
	var value0Raw string

	cmd := &cobra.Command{
		Use:   "transfer-from",
		Short: "Execute the TransferFrom method on a DualFi contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if !calldata {
				if contractAddressRaw == "" {
					return fmt.Errorf("--contract not specified")
				} else if !common.IsHexAddress(contractAddressRaw) {
					return fmt.Errorf("--contract is not a valid Ethereum address")
				}
				contractAddress = common.HexToAddress(contractAddressRaw)

				if keyfile == "" {
					return fmt.Errorf("--keystore not specified (this should be a path to an Ethereum account keystore file)")
				}

				if rpc == "" {
					return fmt.Errorf("--rpc not specified (this should be a URL to an Ethereum JSONRPC API)")
				}
			}

			if safeAddress != "" {
				if !common.IsHexAddress(safeAddress) {
					return fmt.Errorf("--safe is not a valid Ethereum address")
				}
				if safeApi == "" {
					client, clientErr := NewClient(rpc)
					if clientErr != nil {
						return clientErr
					}
					chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
					defer cancelChainIDCtx()
					chainID, chainIDErr := client.ChainID(chainIDCtx)
					if chainIDErr != nil {
						return chainIDErr
					}
					safeApi = fmt.Sprintf("https://safe-client.safe.global/v1/chains/%s/transactions/%s/propose", chainID.String(), safeAddress)
					fmt.Println("--safe-api not specified, using default (", safeApi, ")")
				}

				if SafeOperationType(safeOperationType).String() == "Unknown" {
					return fmt.Errorf("--safe-operation must be 0 (Call) or 1 (DelegateCall)")
				}

				if safeNonceRaw == "" {
					fmt.Println("--safe-nonce not specified, fetching nonce from Safe contract")
				} else {
					safeNonce = new(big.Int)
					_, ok := safeNonce.SetString(safeNonceRaw, 0)
					if !ok {
						return fmt.Errorf("--safe-nonce is not a valid big integer")
					}
				}
			}

			if from0Raw == "" {
				return fmt.Errorf("--from-0 argument not specified")
			} else if !common.IsHexAddress(from0Raw) {
				return fmt.Errorf("--from-0 argument is not a valid Ethereum address")
			}
			from0 = common.HexToAddress(from0Raw)

			if to0Raw == "" {
				return fmt.Errorf("--to-0 argument not specified")
			} else if !common.IsHexAddress(to0Raw) {
				return fmt.Errorf("--to-0 argument is not a valid Ethereum address")
			}
			to0 = common.HexToAddress(to0Raw)

			if value0Raw == "" {
				return fmt.Errorf("--value-0 argument not specified")
			}
			value0 = new(big.Int)
			value0.SetString(value0Raw, 0)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			abi, err := DualFiMetaData.GetAbi()
			if err != nil {
				return fmt.Errorf("failed to get ABI: %v", err)
			}

			// Generate transaction data (override method name if safe function is specified)
			methodName := "transferFrom"
			if safeFunction != "" {
				methodName = safeFunction
			}

			txCalldata, err := abi.Pack(
				methodName,
				from0,
				to0,
				value0,
			)

			if err != nil {
				return err
			}

			if staticCall {
				client, clientErr := NewClient(rpc)
				if clientErr != nil {
					return clientErr
				}

				// Create the call message
				msg := ethereum.CallMsg{
					To:   &contractAddress,
					Data: txCalldata,
				}

				// Create context with timeout
				ctx, cancel := NewChainContext(timeout)
				defer cancel()

				// Perform static call
				output, err := client.CallContract(ctx, msg, nil)
				if err != nil {
					return fmt.Errorf("static call failed: %v", err)
				}

				// Unpack the result
				result, err := abi.Unpack(methodName, output)
				if err != nil {
					return fmt.Errorf("failed to unpack result: %v", err)
				}

				if len(result) > 0 {
					// Get method outputs from ABI to access parameter names
					method, exists := abi.Methods[methodName]
					if !exists {
						return fmt.Errorf("method %s not found in ABI", methodName)
					}

					// Print each return value
					for i, val := range result {
						// Get parameter name if available
						paramName := fmt.Sprintf("output%d", i)
						if i < len(method.Outputs) {
							if method.Outputs[i].Name != "" {
								paramName = method.Outputs[i].Name
							}
						}
						switch v := val.(type) {
						case bool:
							cmd.Printf("%s: %t\n", paramName, v)
						case string:
							cmd.Printf("%s: %s\n", paramName, v)
						case *big.Int:
							cmd.Printf("%s: %s\n", paramName, v.String())
						case common.Address:
							cmd.Printf("%s: %s\n", paramName, v.Hex())
						default:
							rv := reflect.ValueOf(v)
							if rv.Kind() == reflect.Struct {
								PrintStruct(cmd, paramName, rv, 0)
							} else {
								cmd.Printf("%s: %v\n", paramName, v)
							}
						}
					}
				} else {
					return fmt.Errorf("no result returned from static call")
				}

				return nil
			}

			if calldata {
				txCalldataHex := hex.EncodeToString(txCalldata)
				cmd.Println(txCalldataHex)
				return nil
			}

			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			key, keyErr := KeyFromFile(keyfile, password)
			if keyErr != nil {
				return keyErr
			}

			chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
			defer cancelChainIDCtx()
			chainID, chainIDErr := client.ChainID(chainIDCtx)
			if chainIDErr != nil {
				return chainIDErr
			}

			transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
			if transactionOptsErr != nil {
				return transactionOptsErr
			}

			SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

			contract, contractErr := NewDualFi(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			session := DualFiTransactorSession{
				Contract:     &contract.DualFiTransactor,
				TransactOpts: *transactionOpts,
			}

			if safeAddress != "" {
				// Create Safe proposal for transaction
				value := transactionOpts.Value
				if value == nil {
					value = big.NewInt(0)
				}

				err = CreateSafeProposal(client, key, common.HexToAddress(safeAddress), contractAddress, txCalldata, value, safeApi, SafeOperationType(safeOperationType), safeNonce)
				if err != nil {
					return fmt.Errorf("failed to create Safe proposal: %v", err)
				}

				return nil
			}

			transaction, err := session.TransferFrom(

				from0,
				to0,
				value0,
			)
			if err != nil {
				return err
			}

			cmd.Printf("Transaction hash: %s\n", transaction.Hash().Hex())
			if transactionOpts.NoSend {
				estimationMessage := ethereum.CallMsg{
					From: transactionOpts.From,
					To:   &contractAddress,
					Data: transaction.Data(),
				}

				gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
				defer cancelGasEstimationCtx()

				gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
				if gasEstimateErr != nil {
					return gasEstimateErr
				}

				transactionBinary, transactionBinaryErr := transaction.MarshalBinary()
				if transactionBinaryErr != nil {
					return transactionBinaryErr
				}
				transactionBinaryHex := hex.EncodeToString(transactionBinary)

				cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
			} else {
				cmd.Println("Transaction submitted")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
	cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
	cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
	cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
	cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
	cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
	cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&safeAddress, "safe", "", "Address of the Safe contract")
	cmd.Flags().StringVar(&safeApi, "safe-api", "", "Safe API for the Safe Transaction Service (optional)")
	cmd.Flags().Uint8Var(&safeOperationType, "safe-operation", 0, "Safe operation type: 0 (Call) or 1 (DelegateCall)")
	cmd.Flags().StringVar(&safeFunction, "safe-function", "", "Safe function overrider to use for the transaction (optional)")
	cmd.Flags().StringVar(&safeNonceRaw, "safe-nonce", "", "Safe nonce overrider for the transaction (optional)")
	cmd.Flags().BoolVar(&calldata, "calldata", false, "Set this flag if want to return the calldata instead of sending the transaction")
	cmd.Flags().BoolVar(&staticCall, "static-call", false, "Set this flag if want to call the method without sending a transaction")

	cmd.Flags().StringVar(&from0Raw, "from-0", "", "from-0 argument (common.Address)")
	cmd.Flags().StringVar(&to0Raw, "to-0", "", "to-0 argument (common.Address)")
	cmd.Flags().StringVar(&value0Raw, "value-0", "", "value-0 argument")

	return cmd
}
func CreateWithdrawCommand() *cobra.Command {
	var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc, contractAddressRaw, safeFunction, safeNonceRaw string
	var gasLimit uint64
	var simulate bool
	var timeout uint
	var contractAddress common.Address
	var safeAddress, safeApi string
	var safeOperationType uint8
	var safeNonce *big.Int
	var calldata bool
	var staticCall bool

	var amountIn *big.Int
	var amountInRaw string
	var wantNative bool
	var wantNativeRaw string

	cmd := &cobra.Command{
		Use:   "withdraw",
		Short: "Execute the Withdraw method on a DualFi contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if !calldata {
				if contractAddressRaw == "" {
					return fmt.Errorf("--contract not specified")
				} else if !common.IsHexAddress(contractAddressRaw) {
					return fmt.Errorf("--contract is not a valid Ethereum address")
				}
				contractAddress = common.HexToAddress(contractAddressRaw)

				if keyfile == "" {
					return fmt.Errorf("--keystore not specified (this should be a path to an Ethereum account keystore file)")
				}

				if rpc == "" {
					return fmt.Errorf("--rpc not specified (this should be a URL to an Ethereum JSONRPC API)")
				}
			}

			if safeAddress != "" {
				if !common.IsHexAddress(safeAddress) {
					return fmt.Errorf("--safe is not a valid Ethereum address")
				}
				if safeApi == "" {
					client, clientErr := NewClient(rpc)
					if clientErr != nil {
						return clientErr
					}
					chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
					defer cancelChainIDCtx()
					chainID, chainIDErr := client.ChainID(chainIDCtx)
					if chainIDErr != nil {
						return chainIDErr
					}
					safeApi = fmt.Sprintf("https://safe-client.safe.global/v1/chains/%s/transactions/%s/propose", chainID.String(), safeAddress)
					fmt.Println("--safe-api not specified, using default (", safeApi, ")")
				}

				if SafeOperationType(safeOperationType).String() == "Unknown" {
					return fmt.Errorf("--safe-operation must be 0 (Call) or 1 (DelegateCall)")
				}

				if safeNonceRaw == "" {
					fmt.Println("--safe-nonce not specified, fetching nonce from Safe contract")
				} else {
					safeNonce = new(big.Int)
					_, ok := safeNonce.SetString(safeNonceRaw, 0)
					if !ok {
						return fmt.Errorf("--safe-nonce is not a valid big integer")
					}
				}
			}

			if amountInRaw == "" {
				return fmt.Errorf("--amount-in argument not specified")
			}
			amountIn = new(big.Int)
			amountIn.SetString(amountInRaw, 0)

			wantNativeRawLower := strings.ToLower(wantNativeRaw)
			switch wantNativeRawLower {
			case "true", "t", "y", "yes", "1":
				wantNative = true
			case "false", "f", "n", "no", "0":
				wantNative = false
			default:
				return fmt.Errorf("--want-native argument is not valid (value: %s)", wantNativeRaw)
			}

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			abi, err := DualFiMetaData.GetAbi()
			if err != nil {
				return fmt.Errorf("failed to get ABI: %v", err)
			}

			// Generate transaction data (override method name if safe function is specified)
			methodName := "withdraw"
			if safeFunction != "" {
				methodName = safeFunction
			}

			txCalldata, err := abi.Pack(
				methodName,
				amountIn,
				wantNative,
			)

			if err != nil {
				return err
			}

			if staticCall {
				client, clientErr := NewClient(rpc)
				if clientErr != nil {
					return clientErr
				}

				// Create the call message
				msg := ethereum.CallMsg{
					To:   &contractAddress,
					Data: txCalldata,
				}

				// Create context with timeout
				ctx, cancel := NewChainContext(timeout)
				defer cancel()

				// Perform static call
				output, err := client.CallContract(ctx, msg, nil)
				if err != nil {
					return fmt.Errorf("static call failed: %v", err)
				}

				// Unpack the result
				result, err := abi.Unpack(methodName, output)
				if err != nil {
					return fmt.Errorf("failed to unpack result: %v", err)
				}

				if len(result) > 0 {
					// Get method outputs from ABI to access parameter names
					method, exists := abi.Methods[methodName]
					if !exists {
						return fmt.Errorf("method %s not found in ABI", methodName)
					}

					// Print each return value
					for i, val := range result {
						// Get parameter name if available
						paramName := fmt.Sprintf("output%d", i)
						if i < len(method.Outputs) {
							if method.Outputs[i].Name != "" {
								paramName = method.Outputs[i].Name
							}
						}
						switch v := val.(type) {
						case bool:
							cmd.Printf("%s: %t\n", paramName, v)
						case string:
							cmd.Printf("%s: %s\n", paramName, v)
						case *big.Int:
							cmd.Printf("%s: %s\n", paramName, v.String())
						case common.Address:
							cmd.Printf("%s: %s\n", paramName, v.Hex())
						default:
							rv := reflect.ValueOf(v)
							if rv.Kind() == reflect.Struct {
								PrintStruct(cmd, paramName, rv, 0)
							} else {
								cmd.Printf("%s: %v\n", paramName, v)
							}
						}
					}
				} else {
					return fmt.Errorf("no result returned from static call")
				}

				return nil
			}

			if calldata {
				txCalldataHex := hex.EncodeToString(txCalldata)
				cmd.Println(txCalldataHex)
				return nil
			}

			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			key, keyErr := KeyFromFile(keyfile, password)
			if keyErr != nil {
				return keyErr
			}

			chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
			defer cancelChainIDCtx()
			chainID, chainIDErr := client.ChainID(chainIDCtx)
			if chainIDErr != nil {
				return chainIDErr
			}

			transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
			if transactionOptsErr != nil {
				return transactionOptsErr
			}

			SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

			contract, contractErr := NewDualFi(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			session := DualFiTransactorSession{
				Contract:     &contract.DualFiTransactor,
				TransactOpts: *transactionOpts,
			}

			if safeAddress != "" {
				// Create Safe proposal for transaction
				value := transactionOpts.Value
				if value == nil {
					value = big.NewInt(0)
				}

				err = CreateSafeProposal(client, key, common.HexToAddress(safeAddress), contractAddress, txCalldata, value, safeApi, SafeOperationType(safeOperationType), safeNonce)
				if err != nil {
					return fmt.Errorf("failed to create Safe proposal: %v", err)
				}

				return nil
			}

			transaction, err := session.Withdraw(

				amountIn,
				wantNative,
			)
			if err != nil {
				return err
			}

			cmd.Printf("Transaction hash: %s\n", transaction.Hash().Hex())
			if transactionOpts.NoSend {
				estimationMessage := ethereum.CallMsg{
					From: transactionOpts.From,
					To:   &contractAddress,
					Data: transaction.Data(),
				}

				gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
				defer cancelGasEstimationCtx()

				gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
				if gasEstimateErr != nil {
					return gasEstimateErr
				}

				transactionBinary, transactionBinaryErr := transaction.MarshalBinary()
				if transactionBinaryErr != nil {
					return transactionBinaryErr
				}
				transactionBinaryHex := hex.EncodeToString(transactionBinary)

				cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
			} else {
				cmd.Println("Transaction submitted")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
	cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
	cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
	cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
	cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
	cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
	cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&safeAddress, "safe", "", "Address of the Safe contract")
	cmd.Flags().StringVar(&safeApi, "safe-api", "", "Safe API for the Safe Transaction Service (optional)")
	cmd.Flags().Uint8Var(&safeOperationType, "safe-operation", 0, "Safe operation type: 0 (Call) or 1 (DelegateCall)")
	cmd.Flags().StringVar(&safeFunction, "safe-function", "", "Safe function overrider to use for the transaction (optional)")
	cmd.Flags().StringVar(&safeNonceRaw, "safe-nonce", "", "Safe nonce overrider for the transaction (optional)")
	cmd.Flags().BoolVar(&calldata, "calldata", false, "Set this flag if want to return the calldata instead of sending the transaction")
	cmd.Flags().BoolVar(&staticCall, "static-call", false, "Set this flag if want to call the method without sending a transaction")

	cmd.Flags().StringVar(&amountInRaw, "amount-in", "", "amount-in argument")
	cmd.Flags().StringVar(&wantNativeRaw, "want-native", "", "want-native argument (true, t, y, yes, 1 OR false, f, n, no, 0)")

	return cmd
}

var ErrNoRPCURL error = errors.New("no RPC URL provided -- please pass an RPC URL from the command line or set the DUAL_FI_RPC_URL environment variable")

// Generates an Ethereum client to the JSONRPC API at the given URL. If rpcURL is empty, then it
// attempts to read the RPC URL from the DUAL_FI_RPC_URL environment variable. If that is empty,
// too, then it returns an error.
func NewClient(rpcURL string) (*ethclient.Client, error) {
	if rpcURL == "" {
		rpcURL = os.Getenv("DUAL_FI_RPC_URL")
	}

	if rpcURL == "" {
		return nil, ErrNoRPCURL
	}

	client, err := ethclient.Dial(rpcURL)
	return client, err
}

// Creates a new context to be used when interacting with the chain client.
func NewChainContext(timeout uint) (context.Context, context.CancelFunc) {
	baseCtx := context.Background()
	parsedTimeout := time.Duration(timeout) * time.Second
	ctx, cancel := context.WithTimeout(baseCtx, parsedTimeout)
	return ctx, cancel
}

// Unlocks a key from a keystore (byte contents of a keystore file) with the given password.
func UnlockKeystore(keystoreData []byte, password string) (*keystore.Key, error) {
	key, err := keystore.DecryptKey(keystoreData, password)
	return key, err
}

// Loads a key from file, prompting the user for the password if it is not provided as a function argument.
func KeyFromFile(keystoreFile string, password string) (*keystore.Key, error) {
	var emptyKey *keystore.Key
	keystoreContent, readErr := os.ReadFile(keystoreFile)
	if readErr != nil {
		return emptyKey, readErr
	}

	// If password is "", prompt user for password.
	if password == "" {
		fmt.Printf("Please provide a password for keystore (%s): ", keystoreFile)
		passwordRaw, inputErr := term.ReadPassword(int(os.Stdin.Fd()))
		if inputErr != nil {
			return emptyKey, fmt.Errorf("error reading password: %s", inputErr.Error())
		}
		fmt.Print("\n")
		password = string(passwordRaw)
	}

	key, err := UnlockKeystore(keystoreContent, password)
	return key, err
}

// This method is used to set the parameters on a view call from command line arguments (represented mostly as
// strings).
func SetCallParametersFromArgs(opts *bind.CallOpts, pending bool, fromAddress, blockNumber string) {
	if pending {
		opts.Pending = true
	}

	if fromAddress != "" {
		opts.From = common.HexToAddress(fromAddress)
	}

	if blockNumber != "" {
		opts.BlockNumber = new(big.Int)
		opts.BlockNumber.SetString(blockNumber, 0)
	}
}

// This method is used to set the parameters on a transaction from command line arguments (represented mostly as
// strings).
func SetTransactionParametersFromArgs(opts *bind.TransactOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas string, gasLimit uint64, noSend bool) {
	if nonce != "" {
		opts.Nonce = new(big.Int)
		opts.Nonce.SetString(nonce, 0)
	}

	if value != "" {
		opts.Value = new(big.Int)
		opts.Value.SetString(value, 0)
	}

	if gasPrice != "" {
		opts.GasPrice = new(big.Int)
		opts.GasPrice.SetString(gasPrice, 0)
	}

	if maxFeePerGas != "" {
		opts.GasFeeCap = new(big.Int)
		opts.GasFeeCap.SetString(maxFeePerGas, 0)
	}

	if maxPriorityFeePerGas != "" {
		opts.GasTipCap = new(big.Int)
		opts.GasTipCap.SetString(maxPriorityFeePerGas, 0)
	}

	if gasLimit != 0 {
		opts.GasLimit = gasLimit
	}

	opts.NoSend = noSend
}

func CreateDualFiCommand() *cobra.Command {
	cmd := &cobra.Command{
		Use:   "dual-fi",
		Short: "Interact with the DualFi contract",
		Run: func(cmd *cobra.Command, args []string) {
			cmd.Help()
		},
	}

	cmd.SetOut(os.Stdout)

	DeployGroup := &cobra.Group{
		ID: "deploy", Title: "Commands which deploy contracts",
	}
	cmd.AddGroup(DeployGroup)

	VerifyGroup := &cobra.Group{
		ID: "verify", Title: "Commands which verify contract code",
	}
	cmd.AddGroup(VerifyGroup)

	ViewGroup := &cobra.Group{
		ID: "view", Title: "Commands which view contract state",
	}
	TransactGroup := &cobra.Group{
		ID: "transact", Title: "Commands which submit transactions",
	}
	cmd.AddGroup(ViewGroup, TransactGroup)

	cmdDeployDualFi := CreateDualFiDeploymentCommand()
	cmdDeployDualFi.GroupID = DeployGroup.ID
	cmd.AddCommand(cmdDeployDualFi)

	cmdVerify := VerifyContractCodeCommand()
	cmdVerify.GroupID = VerifyGroup.ID
	cmd.AddCommand(cmdVerify)

	cmdViewAllowance := CreateAllowanceCommand()
	cmdViewAllowance.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewAllowance)
	cmdViewBalanceOf := CreateBalanceOfCommand()
	cmdViewBalanceOf.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewBalanceOf)
	cmdViewBasis := CreateBasisCommand()
	cmdViewBasis.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewBasis)
	cmdViewCalculateDistributeAmount := CreateCalculateDistributeAmountCommand()
	cmdViewCalculateDistributeAmount.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewCalculateDistributeAmount)
	cmdViewCalculateWithdrawAmount := CreateCalculateWithdrawAmountCommand()
	cmdViewCalculateWithdrawAmount.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewCalculateWithdrawAmount)
	cmdViewDead := CreateDeadCommand()
	cmdViewDead.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewDead)
	cmdViewDecimals := CreateDecimalsCommand()
	cmdViewDecimals.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewDecimals)
	cmdViewInitialERC20Ratio := CreateInitialErc20RatioCommand()
	cmdViewInitialERC20Ratio.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewInitialERC20Ratio)
	cmdViewInitialNativeRatio := CreateInitialNativeRatioCommand()
	cmdViewInitialNativeRatio.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewInitialNativeRatio)
	cmdViewName := CreateNameCommand()
	cmdViewName.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewName)
	cmdViewSymbol := CreateSymbolCommand()
	cmdViewSymbol.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewSymbol)
	cmdViewToken := CreateTokenCommand()
	cmdViewToken.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewToken)
	cmdViewTotalSupply := CreateTotalSupplyCommand()
	cmdViewTotalSupply.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewTotalSupply)
	cmdViewTrimValue := CreateTrimValueCommand()
	cmdViewTrimValue.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewTrimValue)

	cmdTransactApprove := CreateApproveCommand()
	cmdTransactApprove.GroupID = TransactGroup.ID
	cmd.AddCommand(cmdTransactApprove)
	cmdTransactDeposit := CreateDepositCommand()
	cmdTransactDeposit.GroupID = TransactGroup.ID
	cmd.AddCommand(cmdTransactDeposit)
	cmdTransactSwapNativeForToken := CreateSwapNativeForTokenCommand()
	cmdTransactSwapNativeForToken.GroupID = TransactGroup.ID
	cmd.AddCommand(cmdTransactSwapNativeForToken)
	cmdTransactSwapTokenForNative := CreateSwapTokenForNativeCommand()
	cmdTransactSwapTokenForNative.GroupID = TransactGroup.ID
	cmd.AddCommand(cmdTransactSwapTokenForNative)
	cmdTransactTransfer := CreateTransferCommand()
	cmdTransactTransfer.GroupID = TransactGroup.ID
	cmd.AddCommand(cmdTransactTransfer)
	cmdTransactTransferFrom := CreateTransferFromCommand()
	cmdTransactTransferFrom.GroupID = TransactGroup.ID
	cmd.AddCommand(cmdTransactTransferFrom)
	cmdTransactWithdraw := CreateWithdrawCommand()
	cmdTransactWithdraw.GroupID = TransactGroup.ID
	cmd.AddCommand(cmdTransactWithdraw)

	return cmd
}

// SafeOperationType represents the type of operation for a Safe transaction
type SafeOperationType uint8

const (
	Call         SafeOperationType = 0
	DelegateCall SafeOperationType = 1
)

// String returns the string representation of the SafeOperationType
func (o SafeOperationType) String() string {
	switch o {
	case Call:
		return "Call"
	case DelegateCall:
		return "DelegateCall"
	default:
		return "Unknown"
	}
}

// SafeTransactionData represents the data for a Safe transaction
type SafeTransactionData struct {
	To             string            `json:"to"`
	Value          string            `json:"value"`
	Data           string            `json:"data"`
	Operation      SafeOperationType `json:"operation"`
	SafeTxGas      uint64            `json:"safeTxGas"`
	BaseGas        uint64            `json:"baseGas"`
	GasPrice       string            `json:"gasPrice"`
	GasToken       string            `json:"gasToken"`
	RefundReceiver string            `json:"refundReceiver"`
	Nonce          *big.Int          `json:"nonce"`
	SafeTxHash     string            `json:"safeTxHash"`
	Sender         string            `json:"sender"`
	Signature      string            `json:"signature"`
	Origin         string            `json:"origin"`
}

const (
	NativeTokenAddress = "0x0000000000000000000000000000000000000000"
)

func DeployWithSafe(client *ethclient.Client, key *keystore.Key, safeAddress common.Address, factoryAddress common.Address, value *big.Int, safeApi string, deployBytecode []byte, safeOperationType SafeOperationType, salt [32]byte, safeNonce *big.Int) error {
	abi, err := CreateCall.CreateCallMetaData.GetAbi()
	if err != nil {
		return fmt.Errorf("failed to get ABI: %v", err)
	}

	safeCreateCallTxData, err := abi.Pack("performCreate2", value, deployBytecode, salt)
	if err != nil {
		return fmt.Errorf("failed to pack performCreate2 transaction: %v", err)
	}

	return CreateSafeProposal(client, key, safeAddress, factoryAddress, safeCreateCallTxData, value, safeApi, SafeOperationType(safeOperationType), safeNonce)
}

func PredictDeploymentAddressSafe(from common.Address, salt [32]byte, deployBytecode []byte) (common.Address, error) {
	// Calculate the hash of the init code (deployment bytecode)
	initCodeHash := crypto.Keccak256(deployBytecode)

	// Calculate the CREATE2 address
	deployedAddress := crypto.CreateAddress2(from, salt, initCodeHash)

	return deployedAddress, nil
}

func CreateSafeProposal(client *ethclient.Client, key *keystore.Key, safeAddress common.Address, to common.Address, data []byte, value *big.Int, safeApi string, safeOperationType SafeOperationType, safeNonce *big.Int) error {
	chainID, err := client.ChainID(context.Background())
	if err != nil {
		return fmt.Errorf("failed to get chain ID: %v", err)
	}

	// Create a new instance of the GnosisSafe contract
	safeInstance, err := GnosisSafe.NewGnosisSafe(safeAddress, client)
	if err != nil {
		return fmt.Errorf("failed to create GnosisSafe instance: %v", err)
	}

	nonce := safeNonce
	if safeNonce == nil {
		// Fetch the current nonce from the Safe contract
		fetchedNonce, err := safeInstance.Nonce(&bind.CallOpts{})
		if err != nil {
			return fmt.Errorf("failed to fetch nonce from Safe contract: %v", err)
		}
		nonce = fetchedNonce
	} else {
		nonce = safeNonce
	}

	safeTransactionData := SafeTransactionData{
		To:             to.Hex(),
		Value:          value.String(),
		Data:           common.Bytes2Hex(data),
		Operation:      safeOperationType,
		SafeTxGas:      0,
		BaseGas:        0,
		GasPrice:       "0",
		GasToken:       NativeTokenAddress,
		RefundReceiver: NativeTokenAddress,
		Nonce:          nonce,
	}

	// Calculate SafeTxHash
	safeTxHash, err := CalculateSafeTxHash(safeAddress, safeTransactionData, chainID)
	if err != nil {
		return fmt.Errorf("failed to calculate SafeTxHash: %v", err)
	}

	// Sign the SafeTxHash
	signature, err := crypto.Sign(safeTxHash.Bytes(), key.PrivateKey)
	if err != nil {
		return fmt.Errorf("failed to sign SafeTxHash: %v", err)
	}

	// Adjust V value for Ethereum's replay protection
	signature[64] += 27

	// Convert signature to hex
	senderSignature := "0x" + common.Bytes2Hex(signature)

	// Prepare the request body
	requestBody := map[string]interface{}{
		"to":             safeTransactionData.To,
		"value":          safeTransactionData.Value,
		"data":           "0x" + safeTransactionData.Data,
		"operation":      int(safeTransactionData.Operation),
		"safeTxGas":      fmt.Sprintf("%d", safeTransactionData.SafeTxGas),
		"baseGas":        fmt.Sprintf("%d", safeTransactionData.BaseGas),
		"gasPrice":       safeTransactionData.GasPrice,
		"gasToken":       safeTransactionData.GasToken,
		"refundReceiver": safeTransactionData.RefundReceiver,
		"nonce":          fmt.Sprintf("%d", safeTransactionData.Nonce),
		"safeTxHash":     safeTxHash.Hex(),
		"sender":         key.Address.Hex(),
		"signature":      senderSignature,
		"origin":         fmt.Sprintf("{\"url\":\"%s\",\"name\":\"TokenSender Deployment\"}", safeApi),
	}

	// Marshal the request body to JSON
	jsonBody, err := json.Marshal(requestBody)
	if err != nil {
		return fmt.Errorf("failed to marshal request body: %v", err)
	}

	// Send the request to the Safe Transaction Service
	req, err := http.NewRequest("POST", safeApi, bytes.NewBuffer(jsonBody))
	if err != nil {
		return fmt.Errorf("failed to create request: %v", err)
	}

	req.Header.Set("Content-Type", "application/json")

	httpClient := &http.Client{}
	resp, err := httpClient.Do(req)
	if err != nil {
		return fmt.Errorf("failed to send request: %v", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK && resp.StatusCode != http.StatusCreated {
		return fmt.Errorf("unexpected status code: %d", resp.StatusCode)
	}

	fmt.Println("Safe proposal created successfully")
	return nil
}

func CalculateSafeTxHash(safeAddress common.Address, txData SafeTransactionData, chainID *big.Int) (common.Hash, error) {
	domainSeparator := apitypes.TypedDataDomain{
		ChainId:           (*math.HexOrDecimal256)(chainID),
		VerifyingContract: safeAddress.Hex(),
	}

	typedData := apitypes.TypedData{
		Types: apitypes.Types{
			"EIP712Domain": []apitypes.Type{
				{Name: "chainId", Type: "uint256"},
				{Name: "verifyingContract", Type: "address"},
			},
			"SafeTx": []apitypes.Type{
				{Name: "to", Type: "address"},
				{Name: "value", Type: "uint256"},
				{Name: "data", Type: "bytes"},
				{Name: "operation", Type: "uint8"},
				{Name: "safeTxGas", Type: "uint256"},
				{Name: "baseGas", Type: "uint256"},
				{Name: "gasPrice", Type: "uint256"},
				{Name: "gasToken", Type: "address"},
				{Name: "refundReceiver", Type: "address"},
				{Name: "nonce", Type: "uint256"},
			},
		},
		Domain:      domainSeparator,
		PrimaryType: "SafeTx",
		Message: apitypes.TypedDataMessage{
			"to":             txData.To,
			"value":          txData.Value,
			"data":           "0x" + txData.Data,
			"operation":      fmt.Sprintf("%d", txData.Operation),
			"safeTxGas":      fmt.Sprintf("%d", txData.SafeTxGas),
			"baseGas":        fmt.Sprintf("%d", txData.BaseGas),
			"gasPrice":       txData.GasPrice,
			"gasToken":       txData.GasToken,
			"refundReceiver": txData.RefundReceiver,
			"nonce":          fmt.Sprintf("%d", txData.Nonce),
		},
	}

	typedDataHash, _, err := apitypes.TypedDataAndHash(typedData)
	if err != nil {
		return common.Hash{}, fmt.Errorf("failed to hash typed data: %v", err)
	}

	return common.BytesToHash(typedDataHash), nil
}

func PrintStruct(cmd *cobra.Command, name string, rv reflect.Value, depth int) {
	indent := strings.Repeat("  ", depth)
	cmd.Printf("%s%s:\n", indent, name)

	rt := rv.Type()
	for i := 0; i < rv.NumField(); i++ {
		field := rv.Field(i)
		fieldName := rt.Field(i).Name

		switch f := field.Interface().(type) {
		case common.Address:
			cmd.Printf("%s  %s: %s\n", indent, fieldName, f.Hex())
		case *big.Int:
			cmd.Printf("%s  %s: %s\n", indent, fieldName, f.String())
		default:
			// Check if field is a nested struct
			if field.Kind() == reflect.Struct {
				PrintStruct(cmd, fieldName, field, depth+1)
			} else {
				cmd.Printf("%s  %s: %v\n", indent, fieldName, f)
			}
		}
	}
}

type CompilerInfo struct {
	SolidityVersion string
	EVMVersion      string
}

func ExtractCompilerInfo(bytecode string) (*CompilerInfo, error) {
	// Remove "0x" prefix if present
	bytecode = strings.TrimPrefix(bytecode, "0x")

	if len(bytecode) < 20 {
		return nil, fmt.Errorf("bytecode too short (length: %d)", len(bytecode))
	}

	// Get the last bytes that contain version info
	versionData := bytecode[len(bytecode)-20:]

	// Check for solc identifier '736f6c6343' (which is 'solcC' in hex)
	if !strings.HasPrefix(versionData, "736f6c6343") {
		return nil, fmt.Errorf("no solidity version identifier found in version data: %s", versionData)
	}

	// Skip first 10 chars (736f6c6343)
	versionHex := versionData[10:18]

	// Parse major, minor, and patch versions
	major := int64(0)
	minor, err := strconv.ParseInt(versionHex[2:4], 16, 64)
	if err != nil {
		return nil, fmt.Errorf("failed to parse minor version: %v", err)
	}
	patch, err := strconv.ParseInt(versionHex[4:6], 16, 64)
	if err != nil {
		return nil, fmt.Errorf("failed to parse patch version: %v", err)
	}

	// Determine EVM version based on Solidity version
	evmVersion := determineEVMVersion(major, minor, patch)

	return &CompilerInfo{
		SolidityVersion: fmt.Sprintf("v0.%d.%d", minor, patch), // Changed format string
		EVMVersion:      evmVersion,
	}, nil
}

func determineEVMVersion(major, minor, patch int64) string {
	// This mapping is based on Solidity's default EVM version per compiler version
	// Reference: https://docs.soliditylang.org/en/latest/using-the-compiler.html#target-options
	switch {
	case minor >= 8:
		return "london" // Solidity 0.8.0+ defaults to London
	case minor == 7:
		return "istanbul" // Solidity 0.7.x defaults to Istanbul
	case minor == 6:
		return "istanbul" // Solidity 0.6.x defaults to Istanbul
	case minor == 5 && patch >= 5:
		return "petersburg" // Solidity 0.5.5+ defaults to Petersburg
	case minor == 5:
		return "byzantium" // Solidity 0.5.0-0.5.4 defaults to Byzantium
	default:
		return "homestead" // Earlier versions defaulted to Homestead
	}
}

type EtherscanResponse struct {
	Status  string `json:"status"`
	Message string `json:"message"`
	Result  string `json:"result"`
}

func (r *EtherscanResponse) IsOk() bool {
	return r.Status == "1"
}

func (r *EtherscanResponse) IsBytecodeMissingInNetworkError() bool {
	return strings.Contains(strings.ToLower(r.Message), "missing bytecode")
}

func (r *EtherscanResponse) IsAlreadyVerified() bool {
	return strings.Contains(strings.ToLower(r.Message), "already verified")
}

// SolidityTag represents a tag in the Solidity repository
type SolidityTag struct {
	Object struct {
		SHA string `json:"sha"`
	} `json:"object"`
}

// GetSolidityCommitHash fetches the commit hash for a specific Solidity version tag
func GetSolidityCommitHash(version string) (string, error) {
	// Clean version string (ensure it starts with 'v')
	if !strings.HasPrefix(version, "v") {
		version = "v" + version
	}

	// Create HTTP client with timeout
	client := &http.Client{Timeout: 10 * time.Second}

	// Get tag info from GitHub API
	url := fmt.Sprintf("https://api.github.com/repos/ethereum/solidity/git/refs/tags/%s", version)
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return "", fmt.Errorf("failed to create request: %w", err)
	}

	// Add User-Agent header to avoid GitHub API limitations
	req.Header.Set("User-Agent", "seer-contract-verifier")

	resp, err := client.Do(req)
	if err != nil {
		return "", fmt.Errorf("failed to fetch tag info: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return "", fmt.Errorf("GitHub API returned status %d for version %s", resp.StatusCode, version)
	}

	var tag SolidityTag
	if err := json.NewDecoder(resp.Body).Decode(&tag); err != nil {
		return "", fmt.Errorf("failed to decode GitHub response: %w", err)
	}

	// Return first 8 characters of the commit hash
	if len(tag.Object.SHA) < 8 {
		return "", fmt.Errorf("invalid commit hash length")
	}
	return tag.Object.SHA[:8], nil
}

// GetFullCompilerVersion gets the full compiler version with commit hash
func GetFullCompilerVersion(version string) (string, error) {
	// Get commit hash from GitHub tag
	commitHash, err := GetSolidityCommitHash(version)
	if err != nil {
		return "", fmt.Errorf("failed to get commit hash: %w", err)
	}

	// Format full version string
	fullVersion := fmt.Sprintf("%s+commit.%s", version, commitHash)
	return fullVersion, nil
}

func VerifyContractCode(
	contractAddress common.Address,
	contractCode string,
	apiURL string,
	apiKey string,
	contractName string,
	compilerVersion string,
	runs uint,
	evmVersion string,
	_name0 string,
	symbol string,
	tokenA common.Address,
	initialAmount0Token *big.Int,
	initialAmountNative *big.Int,
	basis *big.Int,
	trimValue *big.Int,
) error {

	fmt.Println("Verifying contract code...")
	fmt.Println("EVM version:", evmVersion)

	// Pack constructor arguments
	abiPacked, err := DualFiMetaData.GetAbi()
	if err != nil {
		return fmt.Errorf("failed to get ABI: %v", err)
	}

	constructorArguments, err := abiPacked.Pack("",
		_name0,
		symbol,
		tokenA,
		initialAmount0Token,
		initialAmountNative,
		basis,
		trimValue,
	)
	if err != nil {
		return fmt.Errorf("failed to pack constructor arguments: %v", err)
	}

	fullCompilerVersion, err := GetFullCompilerVersion(compilerVersion)
	if err != nil {
		return fmt.Errorf("failed to get full compiler version: %w", err)
	}

	fmt.Println("Compiler version:", fullCompilerVersion)

	// Prepare the form data
	formData := url.Values{}
	formData.Set("apikey", apiKey)
	formData.Set("module", "contract")
	formData.Set("action", "verifysourcecode")
	formData.Set("contractaddress", contractAddress.Hex())
	formData.Set("sourceCode", contractCode)
	formData.Set("codeformat", "solidity-single-file")
	formData.Set("contractname", contractName)
	formData.Set("compilerversion", fullCompilerVersion)
	formData.Set("evmversion", evmVersion)
	formData.Set("optimizationUsed", fmt.Sprintf("%t", runs > 0))
	formData.Set("runs", fmt.Sprintf("%d", runs))
	formData.Set("constructorArguments", hex.EncodeToString(constructorArguments))

	// Send the verification request
	// Create HTTP client
	client := &http.Client{
		Timeout: time.Second * 30,
	}

	// Send POST request
	resp, err := client.PostForm(apiURL, formData)
	if err != nil {
		return fmt.Errorf("network request error: %v", err)
	}
	defer resp.Body.Close()

	// Check status code
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return fmt.Errorf("invalid status code: %d", resp.StatusCode)
	}

	// Read and parse response
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("failed to read response body: %v", err)
	}

	var response EtherscanResponse
	if err := json.Unmarshal(body, &response); err != nil {
		return fmt.Errorf("failed to parse response: %v", err)
	}

	// Check for specific error conditions
	if response.IsBytecodeMissingInNetworkError() {
		return fmt.Errorf("contract bytecode not found on network for address %s", contractAddress.Hex())
	}

	if response.IsAlreadyVerified() {
		return fmt.Errorf("contract %s at address %s is already verified", contractName, contractAddress.Hex())
	}

	if !response.IsOk() {
		return fmt.Errorf("verification failed: %s", response.Message)
	}

	guid := response.Result
	fmt.Printf("Contract verification submitted successfully. GUID: %s\n", guid)

	// Check verification status
	fmt.Println("Checking verification status...")
	for i := 0; i < 10; i++ { // Try up to 10 times
		status, err := CheckVerificationStatus(apiURL, apiKey, guid)
		if err != nil {
			return fmt.Errorf("failed to check verification status: %v", err)
		}

		if status == "Pass - Verified" {
			fmt.Println("Contract successfully verified!")
			return nil
		} else if status == "Fail - Unable to verify" {
			return fmt.Errorf("contract verification failed")
		}

		fmt.Println("Verification in progress, waiting 5 seconds...")
		time.Sleep(5 * time.Second)
	}

	return fmt.Errorf("verification status check timed out")
}

func CheckVerificationStatus(apiURL string, apiKey string, guid string) (string, error) {
	// Prepare the query parameters
	params := url.Values{}
	params.Set("apikey", apiKey)
	params.Set("module", "contract")
	params.Set("action", "checkverifystatus")
	params.Set("guid", guid)

	// Create the full URL
	fullURL := fmt.Sprintf("%s?%s", apiURL, params.Encode())

	// Create HTTP client
	client := &http.Client{
		Timeout: time.Second * 10,
	}

	// Send GET request
	resp, err := client.Get(fullURL)
	if err != nil {
		return "", fmt.Errorf("network request error: %v", err)
	}
	defer resp.Body.Close()

	// Check status code
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return "", fmt.Errorf("invalid status code: %d", resp.StatusCode)
	}

	// Read and parse response
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", fmt.Errorf("failed to read response body: %v", err)
	}

	var response EtherscanResponse
	if err := json.Unmarshal(body, &response); err != nil {
		return "", fmt.Errorf("failed to parse response: %v", err)
	}

	return response.Result, nil
}

func VerifyContractCodeCommand() *cobra.Command {
	var contractAddressRaw, apiURL, apiKey string
	var contractAddress common.Address
	var runs uint
	var evmVersion, compilerVersion string

	var _name0 string

	var symbol string

	var tokenA common.Address
	var tokenARaw string
	var initialAmount0Token *big.Int
	var initialAmount0TokenRaw string
	var initialAmountNative *big.Int
	var initialAmountNativeRaw string
	var basis *big.Int
	var basisRaw string
	var trimValue *big.Int
	var trimValueRaw string

	cmd := &cobra.Command{
		Use:   "verify",
		Short: "Verify a contract code on a block explorer",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if DualFiContractCode == "" {
				return fmt.Errorf("contract code is empty, please re-run evm generate passing the --source-code flag")
			}

			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			if tokenARaw == "" {
				return fmt.Errorf("--token-a argument not specified")
			} else if !common.IsHexAddress(tokenARaw) {
				return fmt.Errorf("--token-a argument is not a valid Ethereum address")
			}
			tokenA = common.HexToAddress(tokenARaw)

			if initialAmount0TokenRaw == "" {
				return fmt.Errorf("--initial-amount-0-token argument not specified")
			}
			initialAmount0Token = new(big.Int)
			initialAmount0Token.SetString(initialAmount0TokenRaw, 0)

			if initialAmountNativeRaw == "" {
				return fmt.Errorf("--initial-amount-native argument not specified")
			}
			initialAmountNative = new(big.Int)
			initialAmountNative.SetString(initialAmountNativeRaw, 0)

			if basisRaw == "" {
				return fmt.Errorf("--basis argument not specified")
			}
			basis = new(big.Int)
			basis.SetString(basisRaw, 0)

			if trimValueRaw == "" {
				return fmt.Errorf("--trim-value argument not specified")
			}
			trimValue = new(big.Int)
			trimValue.SetString(trimValueRaw, 0)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			compilerInfo, err := ExtractCompilerInfo(DualFiBin)
			if err != nil {
				return fmt.Errorf("failed to extract compiler info: %v", err)
			}

			if compilerVersion != "" {
				compilerInfo.SolidityVersion = compilerVersion
			}
			if evmVersion != "" {
				compilerInfo.EVMVersion = evmVersion
			}

			return VerifyContractCode(contractAddress, DualFiContractCode, apiURL, apiKey, "DualFi", compilerInfo.SolidityVersion, runs, compilerInfo.EVMVersion, _name0, symbol, tokenA, initialAmount0Token, initialAmountNative, basis, trimValue)
		},
	}

	cmd.Flags().StringVar(&contractAddressRaw, "contract", "c", "The address of the contract to verify")
	cmd.Flags().StringVar(&apiURL, "api", "a", "The block explorer API to use")
	cmd.Flags().StringVar(&apiKey, "api-key", "k", "The API key to use for the block explorer")
	cmd.Flags().UintVar(&runs, "runs", 0, "The number of runs to use for optimization")
	cmd.Flags().StringVar(&evmVersion, "evm-version", "", "Override the EVM version to use for the contract")
	cmd.Flags().StringVar(&compilerVersion, "compiler-version", "", "Override the compiler version to use for the contract")

	cmd.Flags().StringVar(&_name0, "-name-0", "", "-name-0 argument")
	cmd.Flags().StringVar(&symbol, "symbol", "", "symbol argument")
	cmd.Flags().StringVar(&tokenARaw, "token-a", "", "token-a argument (common.Address)")
	cmd.Flags().StringVar(&initialAmount0TokenRaw, "initial-amount-0-token", "", "initial-amount-0-token argument")
	cmd.Flags().StringVar(&initialAmountNativeRaw, "initial-amount-native", "", "initial-amount-native argument")
	cmd.Flags().StringVar(&basisRaw, "basis", "", "basis argument")
	cmd.Flags().StringVar(&trimValueRaw, "trim-value", "", "trim-value argument")

	return cmd
}

const DualFiContractCode = `// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;


// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)

pragma solidity ^0.8.20;

// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)

pragma solidity ^0.8.20;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Emitted when ` + "`" + `value` + "`" + ` tokens are moved from one account (` + "`" + `from` + "`" + `) to
     * another (` + "`" + `to` + "`" + `).
     *
     * Note that ` + "`" + `value` + "`" + ` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a ` + "`" + `spender` + "`" + ` for an ` + "`" + `owner` + "`" + ` is set by
     * a call to {approve}. ` + "`" + `value` + "`" + ` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);

    /**
     * @dev Returns the value of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the value of tokens owned by ` + "`" + `account` + "`" + `.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves a ` + "`" + `value` + "`" + ` amount of tokens from the caller's account to ` + "`" + `to` + "`" + `.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address to, uint256 value) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that ` + "`" + `spender` + "`" + ` will be
     * allowed to spend on behalf of ` + "`" + `owner` + "`" + ` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets a ` + "`" + `value` + "`" + ` amount of tokens as the allowance of ` + "`" + `spender` + "`" + ` over the
     * caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 value) external returns (bool);

    /**
     * @dev Moves a ` + "`" + `value` + "`" + ` amount of tokens from ` + "`" + `from` + "`" + ` to ` + "`" + `to` + "`" + ` using the
     * allowance mechanism. ` + "`" + `value` + "`" + ` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(address from, address to, uint256 value) external returns (bool);
}

// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)

pragma solidity ^0.8.20;

/**
 * @dev Interface for the optional metadata functions from the ERC20 standard.
 */
interface IERC20Metadata is IERC20 {
    /**
     * @dev Returns the name of the token.
     */
    function name() external view returns (string memory);

    /**
     * @dev Returns the symbol of the token.
     */
    function symbol() external view returns (string memory);

    /**
     * @dev Returns the decimals places of the token.
     */
    function decimals() external view returns (uint8);
}

// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)

pragma solidity ^0.8.20;

/**
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }

    function _contextSuffixLength() internal view virtual returns (uint256) {
        return 0;
    }
}

// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)
pragma solidity ^0.8.20;

/**
 * @dev Standard ERC20 Errors
 * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.
 */
interface IERC20Errors {
    /**
     * @dev Indicates an error related to the current ` + "`" + `balance` + "`" + ` of a ` + "`" + `sender` + "`" + `. Used in transfers.
     * @param sender Address whose tokens are being transferred.
     * @param balance Current balance for the interacting account.
     * @param needed Minimum amount required to perform a transfer.
     */
    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);

    /**
     * @dev Indicates a failure with the token ` + "`" + `sender` + "`" + `. Used in transfers.
     * @param sender Address whose tokens are being transferred.
     */
    error ERC20InvalidSender(address sender);

    /**
     * @dev Indicates a failure with the token ` + "`" + `receiver` + "`" + `. Used in transfers.
     * @param receiver Address to which tokens are being transferred.
     */
    error ERC20InvalidReceiver(address receiver);

    /**
     * @dev Indicates a failure with the ` + "`" + `spender` + "`" + `s ` + "`" + `allowance` + "`" + `. Used in transfers.
     * @param spender Address that may be allowed to operate on tokens without being their owner.
     * @param allowance Amount of tokens a ` + "`" + `spender` + "`" + ` is allowed to operate with.
     * @param needed Minimum amount required to perform a transfer.
     */
    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);

    /**
     * @dev Indicates a failure with the ` + "`" + `approver` + "`" + ` of a token to be approved. Used in approvals.
     * @param approver Address initiating an approval operation.
     */
    error ERC20InvalidApprover(address approver);

    /**
     * @dev Indicates a failure with the ` + "`" + `spender` + "`" + ` to be approved. Used in approvals.
     * @param spender Address that may be allowed to operate on tokens without being their owner.
     */
    error ERC20InvalidSpender(address spender);
}

/**
 * @dev Standard ERC721 Errors
 * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.
 */
interface IERC721Errors {
    /**
     * @dev Indicates that an address can't be an owner. For example, ` + "`" + `address(0)` + "`" + ` is a forbidden owner in EIP-20.
     * Used in balance queries.
     * @param owner Address of the current owner of a token.
     */
    error ERC721InvalidOwner(address owner);

    /**
     * @dev Indicates a ` + "`" + `tokenId` + "`" + ` whose ` + "`" + `owner` + "`" + ` is the zero address.
     * @param tokenId Identifier number of a token.
     */
    error ERC721NonexistentToken(uint256 tokenId);

    /**
     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.
     * @param sender Address whose tokens are being transferred.
     * @param tokenId Identifier number of a token.
     * @param owner Address of the current owner of a token.
     */
    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);

    /**
     * @dev Indicates a failure with the token ` + "`" + `sender` + "`" + `. Used in transfers.
     * @param sender Address whose tokens are being transferred.
     */
    error ERC721InvalidSender(address sender);

    /**
     * @dev Indicates a failure with the token ` + "`" + `receiver` + "`" + `. Used in transfers.
     * @param receiver Address to which tokens are being transferred.
     */
    error ERC721InvalidReceiver(address receiver);

    /**
     * @dev Indicates a failure with the ` + "`" + `operator` + "`" + `s approval. Used in transfers.
     * @param operator Address that may be allowed to operate on tokens without being their owner.
     * @param tokenId Identifier number of a token.
     */
    error ERC721InsufficientApproval(address operator, uint256 tokenId);

    /**
     * @dev Indicates a failure with the ` + "`" + `approver` + "`" + ` of a token to be approved. Used in approvals.
     * @param approver Address initiating an approval operation.
     */
    error ERC721InvalidApprover(address approver);

    /**
     * @dev Indicates a failure with the ` + "`" + `operator` + "`" + ` to be approved. Used in approvals.
     * @param operator Address that may be allowed to operate on tokens without being their owner.
     */
    error ERC721InvalidOperator(address operator);
}

/**
 * @dev Standard ERC1155 Errors
 * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.
 */
interface IERC1155Errors {
    /**
     * @dev Indicates an error related to the current ` + "`" + `balance` + "`" + ` of a ` + "`" + `sender` + "`" + `. Used in transfers.
     * @param sender Address whose tokens are being transferred.
     * @param balance Current balance for the interacting account.
     * @param needed Minimum amount required to perform a transfer.
     * @param tokenId Identifier number of a token.
     */
    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);

    /**
     * @dev Indicates a failure with the token ` + "`" + `sender` + "`" + `. Used in transfers.
     * @param sender Address whose tokens are being transferred.
     */
    error ERC1155InvalidSender(address sender);

    /**
     * @dev Indicates a failure with the token ` + "`" + `receiver` + "`" + `. Used in transfers.
     * @param receiver Address to which tokens are being transferred.
     */
    error ERC1155InvalidReceiver(address receiver);

    /**
     * @dev Indicates a failure with the ` + "`" + `operator` + "`" + `s approval. Used in transfers.
     * @param operator Address that may be allowed to operate on tokens without being their owner.
     * @param owner Address of the current owner of a token.
     */
    error ERC1155MissingApprovalForAll(address operator, address owner);

    /**
     * @dev Indicates a failure with the ` + "`" + `approver` + "`" + ` of a token to be approved. Used in approvals.
     * @param approver Address initiating an approval operation.
     */
    error ERC1155InvalidApprover(address approver);

    /**
     * @dev Indicates a failure with the ` + "`" + `operator` + "`" + ` to be approved. Used in approvals.
     * @param operator Address that may be allowed to operate on tokens without being their owner.
     */
    error ERC1155InvalidOperator(address operator);

    /**
     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.
     * Used in batch transfers.
     * @param idsLength Length of the array of token identifiers
     * @param valuesLength Length of the array of token amounts
     */
    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);
}

/**
 * @dev Implementation of the {IERC20} interface.
 *
 * This implementation is agnostic to the way tokens are created. This means
 * that a supply mechanism has to be added in a derived contract using {_mint}.
 *
 * TIP: For a detailed writeup see our guide
 * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How
 * to implement supply mechanisms].
 *
 * The default value of {decimals} is 18. To change this, you should override
 * this function so it returns a different value.
 *
 * We have followed general OpenZeppelin Contracts guidelines: functions revert
 * instead returning ` + "`" + `false` + "`" + ` on failure. This behavior is nonetheless
 * conventional and does not conflict with the expectations of ERC20
 * applications.
 *
 * Additionally, an {Approval} event is emitted on calls to {transferFrom}.
 * This allows applications to reconstruct the allowance for all accounts just
 * by listening to said events. Other implementations of the EIP may not emit
 * these events, as it isn't required by the specification.
 */
abstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {
    mapping(address account => uint256) private _balances;

    mapping(address account => mapping(address spender => uint256)) private _allowances;

    uint256 private _totalSupply;

    string private _name;
    string private _symbol;

    /**
     * @dev Sets the values for {name} and {symbol}.
     *
     * All two of these values are immutable: they can only be set once during
     * construction.
     */
    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
    }

    /**
     * @dev Returns the name of the token.
     */
    function name() public view virtual returns (string memory) {
        return _name;
    }

    /**
     * @dev Returns the symbol of the token, usually a shorter version of the
     * name.
     */
    function symbol() public view virtual returns (string memory) {
        return _symbol;
    }

    /**
     * @dev Returns the number of decimals used to get its user representation.
     * For example, if ` + "`" + `decimals` + "`" + ` equals ` + "`" + `2` + "`" + `, a balance of ` + "`" + `505` + "`" + ` tokens should
     * be displayed to a user as ` + "`" + `5.05` + "`" + ` (` + "`" + `505 / 10 ** 2` + "`" + `).
     *
     * Tokens usually opt for a value of 18, imitating the relationship between
     * Ether and Wei. This is the default value returned by this function, unless
     * it's overridden.
     *
     * NOTE: This information is only used for _display_ purposes: it in
     * no way affects any of the arithmetic of the contract, including
     * {IERC20-balanceOf} and {IERC20-transfer}.
     */
    function decimals() public view virtual returns (uint8) {
        return 18;
    }

    /**
     * @dev See {IERC20-totalSupply}.
     */
    function totalSupply() public view virtual returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See {IERC20-balanceOf}.
     */
    function balanceOf(address account) public view virtual returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev See {IERC20-transfer}.
     *
     * Requirements:
     *
     * - ` + "`" + `to` + "`" + ` cannot be the zero address.
     * - the caller must have a balance of at least ` + "`" + `value` + "`" + `.
     */
    function transfer(address to, uint256 value) public virtual returns (bool) {
        address owner = _msgSender();
        _transfer(owner, to, value);
        return true;
    }

    /**
     * @dev See {IERC20-allowance}.
     */
    function allowance(address owner, address spender) public view virtual returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See {IERC20-approve}.
     *
     * NOTE: If ` + "`" + `value` + "`" + ` is the maximum ` + "`" + `uint256` + "`" + `, the allowance is not updated on
     * ` + "`" + `transferFrom` + "`" + `. This is semantically equivalent to an infinite approval.
     *
     * Requirements:
     *
     * - ` + "`" + `spender` + "`" + ` cannot be the zero address.
     */
    function approve(address spender, uint256 value) public virtual returns (bool) {
        address owner = _msgSender();
        _approve(owner, spender, value);
        return true;
    }

    /**
     * @dev See {IERC20-transferFrom}.
     *
     * Emits an {Approval} event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of {ERC20}.
     *
     * NOTE: Does not update the allowance if the current allowance
     * is the maximum ` + "`" + `uint256` + "`" + `.
     *
     * Requirements:
     *
     * - ` + "`" + `from` + "`" + ` and ` + "`" + `to` + "`" + ` cannot be the zero address.
     * - ` + "`" + `from` + "`" + ` must have a balance of at least ` + "`" + `value` + "`" + `.
     * - the caller must have allowance for ` + "`" + `` + "`" + `from` + "`" + `` + "`" + `'s tokens of at least
     * ` + "`" + `value` + "`" + `.
     */
    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {
        address spender = _msgSender();
        _spendAllowance(from, spender, value);
        _transfer(from, to, value);
        return true;
    }

    /**
     * @dev Moves a ` + "`" + `value` + "`" + ` amount of tokens from ` + "`" + `from` + "`" + ` to ` + "`" + `to` + "`" + `.
     *
     * This internal function is equivalent to {transfer}, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a {Transfer} event.
     *
     * NOTE: This function is not virtual, {_update} should be overridden instead.
     */
    function _transfer(address from, address to, uint256 value) internal {
        if (from == address(0)) {
            revert ERC20InvalidSender(address(0));
        }
        if (to == address(0)) {
            revert ERC20InvalidReceiver(address(0));
        }
        _update(from, to, value);
    }

    /**
     * @dev Transfers a ` + "`" + `value` + "`" + ` amount of tokens from ` + "`" + `from` + "`" + ` to ` + "`" + `to` + "`" + `, or alternatively mints (or burns) if ` + "`" + `from` + "`" + `
     * (or ` + "`" + `to` + "`" + `) is the zero address. All customizations to transfers, mints, and burns should be done by overriding
     * this function.
     *
     * Emits a {Transfer} event.
     */
    function _update(address from, address to, uint256 value) internal virtual {
        if (from == address(0)) {
            // Overflow check required: The rest of the code assumes that totalSupply never overflows
            _totalSupply += value;
        } else {
            uint256 fromBalance = _balances[from];
            if (fromBalance < value) {
                revert ERC20InsufficientBalance(from, fromBalance, value);
            }
            unchecked {
                // Overflow not possible: value <= fromBalance <= totalSupply.
                _balances[from] = fromBalance - value;
            }
        }

        if (to == address(0)) {
            unchecked {
                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.
                _totalSupply -= value;
            }
        } else {
            unchecked {
                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.
                _balances[to] += value;
            }
        }

        emit Transfer(from, to, value);
    }

    /**
     * @dev Creates a ` + "`" + `value` + "`" + ` amount of tokens and assigns them to ` + "`" + `account` + "`" + `, by transferring it from address(0).
     * Relies on the ` + "`" + `_update` + "`" + ` mechanism
     *
     * Emits a {Transfer} event with ` + "`" + `from` + "`" + ` set to the zero address.
     *
     * NOTE: This function is not virtual, {_update} should be overridden instead.
     */
    function _mint(address account, uint256 value) internal {
        if (account == address(0)) {
            revert ERC20InvalidReceiver(address(0));
        }
        _update(address(0), account, value);
    }

    /**
     * @dev Destroys a ` + "`" + `value` + "`" + ` amount of tokens from ` + "`" + `account` + "`" + `, lowering the total supply.
     * Relies on the ` + "`" + `_update` + "`" + ` mechanism.
     *
     * Emits a {Transfer} event with ` + "`" + `to` + "`" + ` set to the zero address.
     *
     * NOTE: This function is not virtual, {_update} should be overridden instead
     */
    function _burn(address account, uint256 value) internal {
        if (account == address(0)) {
            revert ERC20InvalidSender(address(0));
        }
        _update(account, address(0), value);
    }

    /**
     * @dev Sets ` + "`" + `value` + "`" + ` as the allowance of ` + "`" + `spender` + "`" + ` over the ` + "`" + `owner` + "`" + ` s tokens.
     *
     * This internal function is equivalent to ` + "`" + `approve` + "`" + `, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - ` + "`" + `owner` + "`" + ` cannot be the zero address.
     * - ` + "`" + `spender` + "`" + ` cannot be the zero address.
     *
     * Overrides to this logic should be done to the variant with an additional ` + "`" + `bool emitEvent` + "`" + ` argument.
     */
    function _approve(address owner, address spender, uint256 value) internal {
        _approve(owner, spender, value, true);
    }

    /**
     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.
     *
     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by
     * ` + "`" + `_spendAllowance` + "`" + ` during the ` + "`" + `transferFrom` + "`" + ` operation set the flag to false. This saves gas by not emitting any
     * ` + "`" + `Approval` + "`" + ` event during ` + "`" + `transferFrom` + "`" + ` operations.
     *
     * Anyone who wishes to continue emitting ` + "`" + `Approval` + "`" + ` events on the` + "`" + `transferFrom` + "`" + ` operation can force the flag to
     * true using the following override:
     * ` + "`" + `` + "`" + `` + "`" + `
     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {
     *     super._approve(owner, spender, value, true);
     * }
     * ` + "`" + `` + "`" + `` + "`" + `
     *
     * Requirements are the same as {_approve}.
     */
    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {
        if (owner == address(0)) {
            revert ERC20InvalidApprover(address(0));
        }
        if (spender == address(0)) {
            revert ERC20InvalidSpender(address(0));
        }
        _allowances[owner][spender] = value;
        if (emitEvent) {
            emit Approval(owner, spender, value);
        }
    }

    /**
     * @dev Updates ` + "`" + `owner` + "`" + ` s allowance for ` + "`" + `spender` + "`" + ` based on spent ` + "`" + `value` + "`" + `.
     *
     * Does not update the allowance value in case of infinite allowance.
     * Revert if not enough allowance is available.
     *
     * Does not emit an {Approval} event.
     */
    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {
        uint256 currentAllowance = allowance(owner, spender);
        if (currentAllowance != type(uint256).max) {
            if (currentAllowance < value) {
                revert ERC20InsufficientAllowance(spender, currentAllowance, value);
            }
            unchecked {
                _approve(owner, spender, currentAllowance - value, false);
            }
        }
    }
}


// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)

pragma solidity ^0.8.20;

// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)

pragma solidity ^0.8.20;

/**
 * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in
 * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].
 *
 * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by
 * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't
 * need to send a transaction, and thus is not required to hold Ether at all.
 *
 * ==== Security Considerations
 *
 * There are two important considerations concerning the use of ` + "`" + `permit` + "`" + `. The first is that a valid permit signature
 * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be
 * considered as an intention to spend the allowance in any specific way. The second is that because permits have
 * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should
 * take this into consideration and allow a ` + "`" + `permit` + "`" + ` call to fail. Combining these two aspects, a pattern that may be
 * generally recommended is:
 *
 * ` + "`" + `` + "`" + `` + "`" + `solidity
 * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {
 *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}
 *     doThing(..., value);
 * }
 *
 * function doThing(..., uint256 value) public {
 *     token.safeTransferFrom(msg.sender, address(this), value);
 *     ...
 * }
 * ` + "`" + `` + "`" + `` + "`" + `
 *
 * Observe that: 1) ` + "`" + `msg.sender` + "`" + ` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of
 * ` + "`" + `try/catch` + "`" + ` allows the permit to fail and makes the code tolerant to frontrunning. (See also
 * {SafeERC20-safeTransferFrom}).
 *
 * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so
 * contracts should have entry points that don't rely on permit.
 */
interface IERC20Permit {
    /**
     * @dev Sets ` + "`" + `value` + "`" + ` as the allowance of ` + "`" + `spender` + "`" + ` over ` + "`" + `` + "`" + `owner` + "`" + `` + "`" + `'s tokens,
     * given ` + "`" + `` + "`" + `owner` + "`" + `` + "`" + `'s signed approval.
     *
     * IMPORTANT: The same issues {IERC20-approve} has related to transaction
     * ordering also apply here.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - ` + "`" + `spender` + "`" + ` cannot be the zero address.
     * - ` + "`" + `deadline` + "`" + ` must be a timestamp in the future.
     * - ` + "`" + `v` + "`" + `, ` + "`" + `r` + "`" + ` and ` + "`" + `s` + "`" + ` must be a valid ` + "`" + `secp256k1` + "`" + ` signature from ` + "`" + `owner` + "`" + `
     * over the EIP712-formatted function arguments.
     * - the signature must use ` + "`" + `` + "`" + `owner` + "`" + `` + "`" + `'s current nonce (see {nonces}).
     *
     * For more information on the signature format, see the
     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP
     * section].
     *
     * CAUTION: See Security Considerations above.
     */
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;

    /**
     * @dev Returns the current nonce for ` + "`" + `owner` + "`" + `. This value must be
     * included whenever a signature is generated for {permit}.
     *
     * Every successful call to {permit} increases ` + "`" + `` + "`" + `owner` + "`" + `` + "`" + `'s nonce by one. This
     * prevents a signature from being used multiple times.
     */
    function nonces(address owner) external view returns (uint256);

    /**
     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.
     */
    // solhint-disable-next-line func-name-mixedcase
    function DOMAIN_SEPARATOR() external view returns (bytes32);
}

// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)

pragma solidity ^0.8.20;

/**
 * @dev Collection of functions related to the address type
 */
library Address {
    /**
     * @dev The ETH balance of the account is not enough to perform the operation.
     */
    error AddressInsufficientBalance(address account);

    /**
     * @dev There's no code at ` + "`" + `target` + "`" + ` (it is not a contract).
     */
    error AddressEmptyCode(address target);

    /**
     * @dev A call to an address target failed. The target may have reverted.
     */
    error FailedInnerCall();

    /**
     * @dev Replacement for Solidity's ` + "`" + `transfer` + "`" + `: sends ` + "`" + `amount` + "`" + ` wei to
     * ` + "`" + `recipient` + "`" + `, forwarding all available gas and reverting on errors.
     *
     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
     * of certain opcodes, possibly making contracts go over the 2300 gas limit
     * imposed by ` + "`" + `transfer` + "`" + `, making them unable to receive funds via
     * ` + "`" + `transfer` + "`" + `. {sendValue} removes this limitation.
     *
     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].
     *
     * IMPORTANT: because control is transferred to ` + "`" + `recipient` + "`" + `, care must be
     * taken to not create reentrancy vulnerabilities. Consider using
     * {ReentrancyGuard} or the
     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
     */
    function sendValue(address payable recipient, uint256 amount) internal {
        if (address(this).balance < amount) {
            revert AddressInsufficientBalance(address(this));
        }

        (bool success, ) = recipient.call{value: amount}("");
        if (!success) {
            revert FailedInnerCall();
        }
    }

    /**
     * @dev Performs a Solidity function call using a low level ` + "`" + `call` + "`" + `. A
     * plain ` + "`" + `call` + "`" + ` is an unsafe replacement for a function call: use this
     * function instead.
     *
     * If ` + "`" + `target` + "`" + ` reverts with a revert reason or custom error, it is bubbled
     * up by this function (like regular Solidity function calls). However, if
     * the call reverted with no returned reason, this function reverts with a
     * {FailedInnerCall} error.
     *
     * Returns the raw returned data. To convert to the expected return value,
     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[` + "`" + `abi.decode` + "`" + `].
     *
     * Requirements:
     *
     * - ` + "`" + `target` + "`" + ` must be a contract.
     * - calling ` + "`" + `target` + "`" + ` with ` + "`" + `data` + "`" + ` must not revert.
     */
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[` + "`" + `functionCall` + "`" + `],
     * but also transferring ` + "`" + `value` + "`" + ` wei to ` + "`" + `target` + "`" + `.
     *
     * Requirements:
     *
     * - the calling contract must have an ETH balance of at least ` + "`" + `value` + "`" + `.
     * - the called Solidity function must be ` + "`" + `payable` + "`" + `.
     */
    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
        if (address(this).balance < value) {
            revert AddressInsufficientBalance(address(this));
        }
        (bool success, bytes memory returndata) = target.call{value: value}(data);
        return verifyCallResultFromTarget(target, success, returndata);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[` + "`" + `functionCall` + "`" + `],
     * but performing a static call.
     */
    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
        (bool success, bytes memory returndata) = target.staticcall(data);
        return verifyCallResultFromTarget(target, success, returndata);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[` + "`" + `functionCall` + "`" + `],
     * but performing a delegate call.
     */
    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
        (bool success, bytes memory returndata) = target.delegatecall(data);
        return verifyCallResultFromTarget(target, success, returndata);
    }

    /**
     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target
     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an
     * unsuccessful call.
     */
    function verifyCallResultFromTarget(
        address target,
        bool success,
        bytes memory returndata
    ) internal view returns (bytes memory) {
        if (!success) {
            _revert(returndata);
        } else {
            // only check if target is a contract if the call was successful and the return data is empty
            // otherwise we already know that it was a contract
            if (returndata.length == 0 && target.code.length == 0) {
                revert AddressEmptyCode(target);
            }
            return returndata;
        }
    }

    /**
     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the
     * revert reason or with a default {FailedInnerCall} error.
     */
    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {
        if (!success) {
            _revert(returndata);
        } else {
            return returndata;
        }
    }

    /**
     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.
     */
    function _revert(bytes memory returndata) private pure {
        // Look for revert reason and bubble it up if present
        if (returndata.length > 0) {
            // The easiest way to bubble the revert reason is using memory via assembly
            /// @solidity memory-safe-assembly
            assembly {
                let returndata_size := mload(returndata)
                revert(add(32, returndata), returndata_size)
            }
        } else {
            revert FailedInnerCall();
        }
    }
}

/**
 * @title SafeERC20
 * @dev Wrappers around ERC20 operations that throw on failure (when the token
 * contract returns false). Tokens that return no value (and instead revert or
 * throw on failure) are also supported, non-reverting calls are assumed to be
 * successful.
 * To use this library you can add a ` + "`" + `using SafeERC20 for IERC20;` + "`" + ` statement to your contract,
 * which allows you to call the safe operations as ` + "`" + `token.safeTransfer(...)` + "`" + `, etc.
 */
library SafeERC20 {
    using Address for address;

    /**
     * @dev An operation with an ERC20 token failed.
     */
    error SafeERC20FailedOperation(address token);

    /**
     * @dev Indicates a failed ` + "`" + `decreaseAllowance` + "`" + ` request.
     */
    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);

    /**
     * @dev Transfer ` + "`" + `value` + "`" + ` amount of ` + "`" + `token` + "`" + ` from the calling contract to ` + "`" + `to` + "`" + `. If ` + "`" + `token` + "`" + ` returns no value,
     * non-reverting calls are assumed to be successful.
     */
    function safeTransfer(IERC20 token, address to, uint256 value) internal {
        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));
    }

    /**
     * @dev Transfer ` + "`" + `value` + "`" + ` amount of ` + "`" + `token` + "`" + ` from ` + "`" + `from` + "`" + ` to ` + "`" + `to` + "`" + `, spending the approval given by ` + "`" + `from` + "`" + ` to the
     * calling contract. If ` + "`" + `token` + "`" + ` returns no value, non-reverting calls are assumed to be successful.
     */
    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));
    }

    /**
     * @dev Increase the calling contract's allowance toward ` + "`" + `spender` + "`" + ` by ` + "`" + `value` + "`" + `. If ` + "`" + `token` + "`" + ` returns no value,
     * non-reverting calls are assumed to be successful.
     */
    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 oldAllowance = token.allowance(address(this), spender);
        forceApprove(token, spender, oldAllowance + value);
    }

    /**
     * @dev Decrease the calling contract's allowance toward ` + "`" + `spender` + "`" + ` by ` + "`" + `requestedDecrease` + "`" + `. If ` + "`" + `token` + "`" + ` returns no
     * value, non-reverting calls are assumed to be successful.
     */
    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {
        unchecked {
            uint256 currentAllowance = token.allowance(address(this), spender);
            if (currentAllowance < requestedDecrease) {
                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);
            }
            forceApprove(token, spender, currentAllowance - requestedDecrease);
        }
    }

    /**
     * @dev Set the calling contract's allowance toward ` + "`" + `spender` + "`" + ` to ` + "`" + `value` + "`" + `. If ` + "`" + `token` + "`" + ` returns no value,
     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval
     * to be set to zero before setting it to a non-zero value, such as USDT.
     */
    function forceApprove(IERC20 token, address spender, uint256 value) internal {
        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));

        if (!_callOptionalReturnBool(token, approvalCall)) {
            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));
            _callOptionalReturn(token, approvalCall);
        }
    }

    /**
     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
     * on the return value: the return value is optional (but if data is returned, it must not be false).
     * @param token The token targeted by the call.
     * @param data The call data (encoded using abi.encode or one of its variants).
     */
    function _callOptionalReturn(IERC20 token, bytes memory data) private {
        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that
        // the target address contains contract code and also asserts for success in the low-level call.

        bytes memory returndata = address(token).functionCall(data);
        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {
            revert SafeERC20FailedOperation(address(token));
        }
    }

    /**
     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
     * on the return value: the return value is optional (but if data is returned, it must not be false).
     * @param token The token targeted by the call.
     * @param data The call data (encoded using abi.encode or one of its variants).
     *
     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.
     */
    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {
        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false
        // and not revert is the subcall reverts.

        (bool success, bytes memory returndata) = address(token).call(data);
        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;
    }
}


// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)

pragma solidity ^0.8.20;

/**
 * @dev Contract module that helps prevent reentrant calls to a function.
 *
 * Inheriting from ` + "`" + `ReentrancyGuard` + "`" + ` will make the {nonReentrant} modifier
 * available, which can be applied to functions to make sure there are no nested
 * (reentrant) calls to them.
 *
 * Note that because there is a single ` + "`" + `nonReentrant` + "`" + ` guard, functions marked as
 * ` + "`" + `nonReentrant` + "`" + ` may not call one another. This can be worked around by making
 * those functions ` + "`" + `private` + "`" + `, and then adding ` + "`" + `external` + "`" + ` ` + "`" + `nonReentrant` + "`" + ` entry
 * points to them.
 *
 * TIP: If you would like to learn more about reentrancy and alternative ways
 * to protect against it, check out our blog post
 * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 */
abstract contract ReentrancyGuard {
    // Booleans are more expensive than uint256 or any type that takes up a full
    // word because each write operation emits an extra SLOAD to first read the
    // slot's contents, replace the bits taken up by the boolean, and then write
    // back. This is the compiler's defense against contract upgrades and
    // pointer aliasing, and it cannot be disabled.

    // The values being non-zero value makes deployment a bit more expensive,
    // but in exchange the refund on every call to nonReentrant will be lower in
    // amount. Since refunds are capped to a percentage of the total
    // transaction's gas, it is best to keep them low in cases like this one, to
    // increase the likelihood of the full refund coming into effect.
    uint256 private constant NOT_ENTERED = 1;
    uint256 private constant ENTERED = 2;

    uint256 private _status;

    /**
     * @dev Unauthorized reentrant call.
     */
    error ReentrancyGuardReentrantCall();

    constructor() {
        _status = NOT_ENTERED;
    }

    /**
     * @dev Prevents a contract from calling itself, directly or indirectly.
     * Calling a ` + "`" + `nonReentrant` + "`" + ` function from another ` + "`" + `nonReentrant` + "`" + `
     * function is not supported. It is possible to prevent this from happening
     * by making the ` + "`" + `nonReentrant` + "`" + ` function external, and making it call a
     * ` + "`" + `private` + "`" + ` function that does the actual work.
     */
    modifier nonReentrant() {
        _nonReentrantBefore();
        _;
        _nonReentrantAfter();
    }

    function _nonReentrantBefore() private {
        // On the first call to nonReentrant, _status will be NOT_ENTERED
        if (_status == ENTERED) {
            revert ReentrancyGuardReentrantCall();
        }

        // Any calls to nonReentrant after this point will fail
        _status = ENTERED;
    }

    function _nonReentrantAfter() private {
        // By storing the original value once again, a refund is triggered (see
        // https://eips.ethereum.org/EIPS/eip-2200)
        _status = NOT_ENTERED;
    }

    /**
     * @dev Returns true if the reentrancy guard is currently set to "entered", which indicates there is a
     * ` + "`" + `nonReentrant` + "`" + ` function in the call stack.
     */
    function _reentrancyGuardEntered() internal view returns (bool) {
        return _status == ENTERED;
    }
}


pragma solidity ^0.8.19;

interface IDualFi {
    function deposit(uint256 value) external payable returns (uint256 amount);

    function withdraw(
        uint256 amountIn,
        bool wantNative
    ) external returns (uint256 amount);

    function swapNativeForToken() external payable returns (uint256 amount);

    function swapTokenForNative(
        uint256 amountIn
    ) external returns (uint256 amount);

    function calculateDistributeAmount(
        uint256 erc20Value,
        uint256 nativeValue
    ) external view returns (uint256 amount);

    function calculateWithdrawAmount(
        uint256 amountIn,
        bool wantNative
    ) external view returns (uint256 amount);

    function basis() external view returns (uint256);

    function trimValue() external view returns (uint256);

    function initialNativeRatio() external view returns (uint256);

    function initialERC20Ratio() external view returns (uint256);

    function token() external view returns (address);

    function dead() external view returns (address);
}


contract DualFi is ERC20, ReentrancyGuard, IDualFi {
    using SafeERC20 for IERC20;
    address public immutable token;
    uint256 public immutable basis;
    address public dead = address(0xdead);
    uint256 public immutable initialNativeRatio;
    uint256 public immutable initialERC20Ratio;
    uint256 public immutable trimValue;

    constructor(
        string memory _name,
        string memory _symbol,
        address tokenA,
        uint256 initialAmount0Token,
        uint256 initialAmountNative,
        uint256 _basis,
        uint256 _trimValue
    ) ERC20(_name, _symbol) {
        token = tokenA;
        require(_basis > 1, "Basis needs to be greater than 1");
        basis = _basis;
        trimValue = _trimValue;
        initialERC20Ratio = initialAmount0Token;
        initialNativeRatio = initialAmountNative;
    }

    function deposit(
        uint256 value
    ) external payable nonReentrant returns (uint256 amount) {
        uint256 nativeValue = msg.value;
        amount = calculateDistributeAmount(value, nativeValue);
        if (value > 0) {
            IERC20(token).safeTransferFrom(msg.sender, address(this), value);
        }
        __mint(msg.sender, amount);
        _trackTrim();
        return amount;
    }

    function calculateDistributeAmount(
        uint256 erc20Value,
        uint256 nativeValue
    ) public view returns (uint256 amount) {
        uint256 halfSupply = totalSupply() / 2;

        if (address(this).balance > nativeValue) {
            amount = (halfSupply * nativeValue) / address(this).balance;
        } else {
            amount = initialNativeRatio * nativeValue;
        }

        if (IERC20(token).balanceOf(address(this)) > 0) {
            amount +=
                (halfSupply * erc20Value) /
                IERC20(token).balanceOf(address(this));
        } else {
            amount += initialERC20Ratio * erc20Value;
        }

        amount = (amount / basis) * (basis - 1);
    }

    function withdraw(
        uint256 amountIn,
        bool wantNative
    ) external nonReentrant returns (uint256 amount) {
        _burn(msg.sender, amountIn);

        amount = calculateWithdrawAmount(amountIn, wantNative);

        if (wantNative) {
            (bool success, ) = msg.sender.call{value: amount}("");
            require(success, "Native transfer failed");
        } else {
            IERC20(token).safeTransfer(msg.sender, amount);
        }
    }

    function calculateWithdrawAmount(
        uint256 amountIn,
        bool wantNative
    ) public view returns (uint256 amount) {
        uint256 halfSupply = totalSupply() / 2;
        if (halfSupply == 0) {
            amount = 0;
        } else {
            if (wantNative) {
                amount = (address(this).balance * amountIn) / halfSupply;
                //Ensure amount is not greater than balance
                amount = amount > address(this).balance
                    ? address(this).balance
                    : amount;
            } else {
                amount =
                    (IERC20(token).balanceOf(address(this)) * amountIn) /
                    halfSupply;
                //ensure amount is not greater than balance
                amount = amount > IERC20(token).balanceOf(address(this))
                    ? IERC20(token).balanceOf(address(this))
                    : amount;
            }
            amount = (amount / basis) * (basis - 1);
        }
    }

    function _trackTrim() internal {
        if (balanceOf(dead) >= trimValue) {
            _burn(dead, trimValue / 2);
        }
    }

    function internalSwap(
        uint256 amountIn,
        bool wantNative
    ) internal returns (uint256 amount) {
        __mint(address(this), amountIn);
        amount = calculateWithdrawAmount(amountIn, wantNative);
        _burn(address(this), balanceOf(address(this)));
    }

    function swapNativeForToken()
        external
        payable
        nonReentrant
        returns (uint256 amount)
    {
        amount = calculateDistributeAmount(0, msg.value);
        amount = internalSwap(amount, false);
        IERC20(token).safeTransfer(msg.sender, amount);
        _trackTrim();
    }

    function swapTokenForNative(
        uint256 amountIn
    ) external nonReentrant returns (uint256 amount) {
        IERC20(token).safeTransferFrom(msg.sender, address(this), amountIn);
        amount = calculateDistributeAmount(amountIn, 0);
        amount = internalSwap(amount, true);
        (bool success, ) = msg.sender.call{value: amount}("");
        require(success, "Native transfer failed");
        _trackTrim();
    }

    function __mint(address to, uint256 amount) internal {
        _mint(to, amount);
        _mint(dead, amount / (basis - 1));
    }
}
`
